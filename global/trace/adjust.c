/*$Id: adjust.c,v 1.3 1995-10-17 08:53:48 d3g681 Exp $*/
/***********************************************************************\
* Purpose: adjusts timers in tracefiles generated by ga_trace,          *
*          sorts events, combines tracefiles, and reformats the data    *
* Jarek Nieplocha, 10.15.1993                                           *
\***********************************************************************/

#include <stdio.h>
#define MAX_EVENTS 202500
#define MAX_ARRAYS 8
#define MAX_EVENT_TYPES 15
#define MAX_PROC 512 

#define abs(x) ((x)>0 ? (x) :(-x))

int proc=0, arrays=0; event_types=0; 


double stat[MAX_PROC][MAX_ARRAYS][MAX_EVENT_TYPES];
unsigned int acc[MAX_PROC][MAX_ARRAYS][MAX_EVENT_TYPES];

void printstat(), update();


main(argc,argv)
int argc;
char **argv;
{
long int p,i,j,k,MR,events=0;
unsigned long int  *clock_base, *times, base=0, *tbase, maxtime=0;
int *record;
int ga=3;

static int tcomp();
int flag;
          
FILE *fin,*fout;
char *foutname = "adjust.ed", finname[8];

   if(argc<2){
      printf("Usage: adjust <number of processors> [<max number of events>] [<array>]\n");
      exit(1);
   } 
   sscanf(argv[1],"%ld",&p);
   if(argc>2) sscanf(argv[2],"%ld",&MR);
   if(argc>3) sscanf(argv[3],"%d",&ga);
   else MR =  MAX_EVENTS;
   
   if(p>MAX_PROC){
     printf("only MAX_PROC allowed -- modify and recompile the program\n"); 
     exit(1);
   }

   printf("Processing tracefiles for %d processors\n",p);

   for(i=0;i<p;i++)for(j=0;j<MAX_ARRAYS;j++) for(k=0;k<MAX_EVENT_TYPES;k++){
     stat[i][j][k]=0.; 
     acc[i][j][k]=0;
   }
 
   if(!(clock_base = (unsigned long int *)malloc(p*sizeof(unsigned long int)))){
                     printf("couldn't allocate memory 1\n");
                     exit(2);
   }
   if(!(record = (int*)malloc(7*MR*sizeof(int)))){
                     printf("couldn't allocate memory 2\n");
                     exit(2);
   }
   if(!(times = (unsigned long int *)malloc(4*MR*sizeof(unsigned long int)))){
                     printf("couldn't allocate memory 3\n");
                     exit(2);
   }
   
   base = 0; tbase = times; events=0;
   for(i=0;i<p;i++){
/*      printf("file %d\n",i);*/
      sprintf(finname,"%03d",i);
      fin = fopen(finname,"r");
      if(!fin){
          printf("%s: File Not Found, Exiting ...\n",finname);
          exit(3);
      }

      for(k=0;k<7;k++) fscanf(fin,"%d",&flag);
      fscanf(fin,"%lu", clock_base+i);
      fscanf(fin,"%lu", clock_base+i);

      for(j=0;;j++){
          for(k=base;k<7+base;k++)fscanf(fin,"%d",(record+k)); 
          fscanf(fin,"%lu",times);
          if(feof(fin))break;
          times[0] -= clock_base[i]; 
          times[1] = base+1;  
          fscanf(fin,"%lu",times+2);

          times[2] -= clock_base[i];
          update(i,record+base,times[0],times[2]);
          times[3] = -base-1; 

          if(maxtime<times[2])maxtime=times[2]; /*find the end time */

          /* advance pointers only for the required array */
          if(record[base+1]==ga){
             times+=4; 
             base += 7;
             events++;
          }
      }
      fclose(fin);
   }
   
   printstat(p, maxtime);

   /* sorting events */
   
   times = tbase; 
/*   printf("\nsorting %d\n",2*events);*/
   qsort(tbase, 2*events, 2*sizeof(unsigned long int), tcomp);
   printf("%d events sorted\n",events);
   
   /* output */

      
   fout = fopen(foutname,"w");
   for(i=0;i<events*2;i++){
      base = abs((long int)times[1]); base -=1;
      flag = ((long int)times[1]) < 0 ? -1 : 1; 
      for(k=base;k<7+base;k++)fprintf(fout,"%d ",*(record+k)); 
      fprintf(fout,"%d ",flag);
      fprintf(fout,"%lu\n",times[0]);
      times += 2;
   }     
   
   fclose(fout);
}
   
      
static int tcomp(t1, t2)
unsigned long int *t1, *t2;
{
int flag;
    flag = (*t1 == *t2) ? 0 :(*t1 > *t2 ? 1 : -1);
    return (flag);
}


void update(proc,record, t0, t1)
long int proc;
int *record;
unsigned long t0,t1;
{
int ar=record[1], et=record[6];

  if(arrays < ar){
     arrays = ar;
     if(arrays>= MAX_ARRAYS){
       printf("The program can handle only %d arrays\n",MAX_ARRAYS);
       exit(1);
     }
  }
  if(event_types < et){
     event_types = et;
     if (event_types >= MAX_EVENT_TYPES){
       printf("The program can handle only %d event types%d\n",MAX_EVENT_TYPES,et);
       exit(1);
     }
  }
  stat[proc][ar][et] += 1e-6 * (double)(t1-t0);
  acc[proc][ar][et] ++;
}


#define MAX(a,b) (((a) >= (b)) ? (a) : (b))

void printstat(proc,tlast)
int proc;
unsigned tlast;
{
int p,e,a;
double t,tp,ta,te, tl= 1e-6 * tlast;
double total_cm=0., total_cp=0.;
long int i, ia, ip, ie;

  printf("\t\t\tActivity Statistics\n",p);
  for(p=0;p<proc;p++){
     t=0.;  
     printf("Processor %3d:\n~~~~~~~~~~~~~\n",p);
     printf(" EventCode   NumberOfEvents   TotalEventTime   AverageTime\n");
     for(e=0; e<=event_types; e++){
        te =0.; ie=0;
        for(a=0;a<=arrays;a++){
           te += stat[p][a][e];
           ie += acc[p][a][e];
        }
        if(ie)printf(" %6d  %12d \t     %14g %14g\n",e,ie, te, te/ie);
        t += te;
     }
     printf("   Array     NumberOfEvents   TotalEventTime   AverageTime\n");
     for(a=0; a<=arrays; a++){
        ta =0.; ia=0;
        for(e=0; e<=event_types; e++){
           ta += stat[p][a][e];
           ia += acc[p][a][e];
        }
        if(ia)printf(" %6d  %12d \t     %14g %14g\n",a,ia, ta, ta/ia);
     }
     total_cm += t; total_cp += MAX(tl-t,0.);
     printf(" Time in GAs:      %14g\n Time outside GAs: %14g\n\n",t,MAX(tl-t,0.));
  }

  printf("\n Total CPU time used [node-seconds]: \n");
  printf(" Time in GAs:      %14g\n Time outside GAs: %14g\n\n",total_cm,total_cp);
}
     

