<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<!-- DO NOT EDIT:  this is a cleared public file -->

<HEAD>
   <TITLE> GA Operations </TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (X11; I; IRIX64 6.2 IP28) [Netscape]">
</HEAD>
<BODY BACKGROUND="gif/orange_paper_2.gif">

<H3><A NAME="ga_initialize"></A>GA_INITIALIZE </H3>

<PRE>      subroutine ga_initialize()

</PRE>

<P>Allocate and initialize internal data structures for Global Arrays.
</P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_initialize_ltd"></A>GA_INITIALIZE_LTD </H3>

<PRE>      subroutine ga_initialize_ltd(limit)
      integer limit  - amount of memory in bytes per process [input]


</PRE>

<P>Allocate and initialize internal data structures for global arrays and
set limit for memory used in global arrays. </P>

<P><I>limit</I> &lt; 0 means &quot;allow unlimited memory usage&quot; </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_create"></A>GA_CREATE </H3>

<PRE>      logical function ga_create(type, dim1, dim2, array_name, chunk1, chunk2, g_a)

      integer type, dim1, dim2, chunk1, chunk2, g_a
      character*(*) array_name

      array_name        - a unique character string [input]
      type              - MA type [input]
      dim1/2            - array(dim1,dim2) as in FORTRAN [input]
      chunk1/2          - minimum size that dimensions should
                          be chunked up into [input]
      g_a               - integer handle for future references [output]


</PRE>

<P>Creates an array. </P>

<P>Setting <I>chunk1</I>=<I>dim1 </I>gives distribution by vertical strips
(<I>chunk2*columns</I>); setting <I>chunk2=dim2 </I>gives distribution
by horizontal strips (<I>chunk1*rows</I>). Actual chunks will be modified
so that they are at least the size of the minimum and each process has
either zero or one chunk. Specifying <I>chunk1/2</I> as &lt;= 1 will cause
that dimension to be distributed evenly. </P>

<P>Note: current distribution algorithm is primitive. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_create_irreg"></A>GA_CREATE_IRREG </H3>

<PRE>      logical function ga_create_irreg(type, dim1, dim2, array_name, map1, nblock1, map2, nblock2, g_a)

      integer type, map1(*), map2(*), nblock1, nblock2, g_a
      character*(*) array_name

       array_name    - a unique character string [input]
       type          - MA type [input]
       dim1/2        - array(dim1,dim2) as in FORTRAN [input]
       nblock1       - no. of blocks first dimension is divided into [input]
       nblock2       - no. of blocks second dimension is divided into [input]
       map1          - ilo for each block [input]
       map2          - jlo for each block [input]
       g_a           - integer handle for future references [output]


</PRE>

<P>Creates an array by following the user-specified distribution. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_duplicate"></A>GA_DUPLICATE </H3>

<PRE>      logical function ga_duplicate(g_a, g_b, array_name)
      integer         g_a, g_b;
      character*(*)   array_name;

      array_name    - a character string                 [input]
      g_a           - Integer handle for reference array [input]
      g_b           - Integer handle for new array       [output]

</PRE>

<P>Creates a new array by applying all the properties of another existing
array. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_destroy"></A>GA_DESTROY </H3>

<PRE>      logical function ga_destroy(g_a)
  
      integer g_a     [input]

</PRE>

<P>Deallocates the array and frees any associated resources. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_terminate"></A>GA_TERMINATE </H3>

<PRE>      subroutine ga_terminate()

</PRE>

<P>Delete all active arrays and destroy internal data structures. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_sync"></A>GA_SYNC </H3>

<PRE>      subroutine ga_sync()

</PRE>

<P>Synchronize processes (a barrier) and ensure that all global array operations
are complete (or at least appear complete). </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_zero"></A>GA_ZERO </H3>

<PRE>      subroutine ga_zero(g_a)

      integer g_a                         [input]

</PRE>

<P>Sets value of all elements in the array to zero. </P>

<P>This is a collective operation.<BR>

<HR><BR>
<BR>
</P>

<H3><A NAME="ga_ddot"></A>GA_DDOT </H3>

<PRE>      double precision function ga_ddot(g_a, g_b)

      integer g_a, g_b                    [input]

</PRE>

<P>Computes the element-wise dot product of the two arrays which must be
double precision, the same shape and identically aligned:</P>

<PRE>         ga_ddot = SUM_ij a(i,j)*b(i,j)</PRE>

<P><BR>
This is a collective operation.<BR>

<HR><BR>
</P>

<H3><A NAME="ga_zdot"></A>GA_ZDOT </H3>

<PRE>      double complex function ga_zdot(g_a, g_b)

      integer g_a, g_b                    [input]

</PRE>

<P>Computes the element-wise dot product of the two arrays which must be
double complex, the same shape and identically aligned: </P>

<PRE>         ga_zdot = SUM_ij a(i,j)*b(i,j)</PRE>

<P><BR>
This is a collective operation.<BR>

<HR><BR>
<BR>
</P>

<H3><A NAME="ga_ddot_patch"></A>GA_DDOT_PATCH </H3>

<PRE>      double precision function ga_ddot_patch(g_a, ta, ailo, aihi, ajlo, ajhi,
                                              g_b, tb, bilo, bihi, bjlo, bjhi) 

      integer     g_a, g_b                   [input]
      integer     ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates
      integer     bilo, bihi, bjlo, bjhi     [input] g_b patch coordinates
      character*1 ta, tb                     [input] transpose flags


</PRE>

<P>Computes the element-wise dot product of the two (possibly transposed)
patches which must be double precision and have the same number of elements.
</P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_zdot_patch"></A>GA_ZDOT_PATCH </H3>

<PRE>      double complex function ga_zdot_patch(g_a, ta, ailo, aihi, ajlo, ajhi,
                                            g_b, tb, bilo, bihi, bjlo, bjhi)

      integer     g_a, g_b                   [input]
      integer     ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates
      integer     bilo, bihi, bjlo, bjhi     [input] g_b patch coordinates
      character*1 ta, tb                     [input] transpose flags


</PRE>

<P>Computes the element-wise dot product of the two (possibly transposed)
patches which must be double complex and have the same number of elements.
</P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_matmul_patch"></A>GA_MATMUL_PATCH </H3>

<PRE>     subroutine ga_matmul_patch(transa, transb, alpha, beta,
                                 g_a, ailo, aihi, ajlo, ajhi,
                                 g_b, bilo, bihi, bjlo, bjhi,
                                 g_c, cilo, cihi, cjlo, cjhi)

     integer g_a, ailo, aihi, ajlo, ajhi    [input]  patch of g_a
     integer g_b, bilo, bihi, bjlo, bjhi    [input]  patch of g_b
     integer g_c, cilo, cihi, cjlo, cjhi    [input]  patch of g_c 
     double precision/complex alpha, beta   [input]
     character*1    transa, transb          [input]


</PRE>

<P>ga_matmul_patch is a patch version of <A HREF="#ga_dgemm">ga_dgemm</A>:
</P>

<PRE>         <I>C</I>[<I>cilo</I>:<I>cihi</I>,<I>cjlo</I>:<I>cjhi</I>] := <I>alpha</I>* <I>AA</I>[<I>ailo</I>:<I>aihi</I>,<I>ajlo</I>:<I>ajhi</I>] *
                                   <I>BB</I>[<I>bilo:bihi,bjlo:bjhi</I>] ) + <I>beta</I>*<I>C</I>[<I>cilo:cihi,cjlo:cjhi</I>],

</PRE>

<P>where <I>AA</I> = <I>op</I>(<I>A</I>), <I>BB</I> = <I>op</I>(<I>B</I>),
and <I>op</I>(<I> X</I> ) is one of </P>

<PRE>         <I>op</I>( <I>X</I> ) = <I>X</I>   or   <I>op</I>( <I>X</I> ) = <I>X'</I>,

</PRE>

<P>Valid values for transpose arguments: '<I>n</I>', '<I>N</I>', '<I>t</I>',
'<I>T</I>'. It works for both <I>double precision</I> and <I>double complex</I>
data tape. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_scale"></A>GA_SCALE </H3>

<PRE>      subroutine ga_scale(g_a, s)
 
      integer g_a                         [input]
      double precision/complex/integer s  [input]


</PRE>

<P>Scales an array by the constant <I>s</I>. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_scale_patch"></A>GA_SCALE_PATCH </H3>

<PRE>      subroutine ga_scale_patch(g_a, ailo, aihi, ajlo, ajhi, s)

      integer g_a                         [input]
      double precision/complex/integer s  [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates

</PRE>

<P>Scales a patch of an array by the constant <I>s</I>. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_add"></A>GA_ADD </H3>

<PRE>      subroutine ga_add(alpha, g_a, beta, g_b, g_c)

      integer g_a, g_b, g_c                          [input]
      double precision/complex/integer alpha, beta   [input]

</PRE>

<P>The arrays (which must be the same shape and identically aligned) are
added together element-wise </P>

<PRE>           <I>c</I> = <I>alpha * a </I> +  <I>beta * b</I>.

</PRE>

<P>The result (<I>c</I>) may replace one of the input arrays (<I>a/b</I>).
</P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_add_patch"></A>GA_ADD_PATCH </H3>

<PRE>      subroutine ga_add_patch (alpha, g_a, ailo, aihi, ajlo, ajhi,
                               beta,  g_b, bilo, bihi, bjlo, bjhi,
                                      g_c, cilo, cihi, cjlo, cjhi)

      integer g_a, g_b, g_c                        [input]
      double precision/complex/integer alpha, beta [input]
      integer  ailo, aihi, ajlo, ajhi              [input] g_a patch coordinates
      integer  bilo, bihi, bjlo, bjhi              [input] g_b patch coordinates
      integer  cilo, cihi, cjlo, cjhi              [input] g_c patch coordinates


</PRE>

<P>Patches of arrays (which must have the same number of elements) are
added together element-wise. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_fill_patch"></A>GA_FILL_PATCH </H3>

<PRE>      subroutine ga_fill_patch(g_a, ailo, aihi, ajlo, ajhi, s)

      integer g_a                         [input]
      double precision/complex/integer s  [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates


</PRE>

<P>Fills the patch of an array with value <I>s</I>. Type of <I>s</I> and
array must match. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_summarize"></A>GA_SUMMARIZE </H3>

<PRE>      subroutine ga_summarize(verbose)
      logical verbose                     [input]! If true print 
                                                   distribution info

</PRE>

<P>Prints info about allocated arrays. </P>

<P>
<HR></P>

<H3><A NAME="ga_symmetrize"></A>GA_SYMMETRIZE </H3>

<PRE>      subroutine ga_symmetrize(g_a)

      integer g_a                         [input/output]


</PRE>

<P>Symmetrizes matrix <I>A</I> represented with handle <I>g_a</I>: <I>A</I>:=
.5 * (<I>A</I>+<I>A</I>'). </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_transpose"></A>GA_TRANSPOSE </H3>

<PRE>      subroutine ga_transpose(g_a, g_b)

      integer g_a                         [input]  ! remains unchanged
      integer g_b                         [output]


</PRE>

<P>Transposes a matrix: <I>B </I>= <I>A</I>', where <I>A</I> and <I>B</I>
are represented by handles <I>g_a</I> and <I>g_b</I>.</P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_diag"></A>GA_DIAG </H3>

<PRE>      subroutine ga_diag(g_a, g_s, g_v, eval)

      integer g_a               [input]   ! Matrix to diagonalize
      integer g_s               [input]   ! Metric
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals


</PRE>

<P>Solve the generalized eigen-value problem returning all eigen-vectors
and values in ascending order. The input matrices are not overwritten or
destroyed. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_diag_reuse"></A>GA_DIAG_REUSE </H3>

<PRE>      subroutine ga_diag_reuse(control, g_a, g_s, g_v, eval)

      integer control           [input]   ! Control flag 
      integer g_a               [input]   ! Matrix to diagonalize
      integer g_s               [input]   ! Metric
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals


</PRE>

<P>Solve the generalized eigen-value problem returning all eigen-vectors
and values in ascending order. Recommended for REPEATED calls if g_s is
unchanged. Values of the control flag: </P>

<PRE>             value       action/purpose
   
              0          indicates first call to the eigensolver
             &gt;0          consecutive calls (reuses factored g_s)
             &lt;0          only erases factorized g_s; g_v and eval unchanged
                         (should be called after previous use if another 
                         eigenproblem, i.e., different g_a and g_s, is to 
                         be solved)
</PRE>

<P>The input matrices are not destroyed. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_diag_std"></A>GA_DIAG_STD </H3>

<PRE>      subroutine ga_diag_std(g_a, g_v, eval)

      integer g_a               [input]   ! Matrix to diagonalize
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals


</PRE>

<P>Solve the standard (non-generalized) eigenvalue problem returning all
eigenvectors and values in the ascending order. The input matrix is neither
overwritten nor destroyed. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_lu_solve"></A>GA_LU_SOLVE </H3>

<PRE>      subroutine ga_lu_solve(trans, g_a, g_b)

      character trans           [input]          ! transpose or not transpose 
      integer g_a               [input]          ! coefficient matrix
      integer g_b               [output/output]  ! rhs/solution matrix


</PRE>

<P>Solve the system of linear equations <I>op</I>(<I>A</I>)<I>X </I>= <I>B</I>
based on the LU factorization. </P>

<P><I>op</I>(A) = <I>A</I> or <I>A'</I> depending on the parameter <I>trans:</I></P>

<DD><I>trans</I> = 'N' or 'n' means that the transpose operator should
<B>not</B> be applied. </DD>

<DD><I>trans</I> = 'T' or 't' means that the transpose operator should
be applied.</DD>

<P>Matrix A is a general real matrix. Matrix B contains possibly multiple
rhs vectors. The array associated with the handle <I>g_b</I> is overwritten
by the solution matrix <I>X</I>. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_cholesky"></A>GA_CHOLESKY </H3>

<PRE>      integer function ga_cholesky(uplo, g_a)
      character uplo            [input]           ! lower/upper triangle
      integer g_a               [input/output]    ! matrix


</PRE>

<P>Computes Cholesky factorization for an SPD matrix. The result overwrites
the original matrix. The input flag uplo ('L' or 'U') determines if lower
or upper triangular matrix is created. </P>

<P>It returns </P>

<PRE>            = 0 : successful exit
            &gt; 0 : the leading minor of this order
                  is not positive definite and the
                  factorization could not be completed</PRE>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_spd_invert"></A>GA_SPD_INVERT </H3>

<PRE>      integer function ga_spd_invert(g_a)
      integer g_a               [input/output]    ! matrix


</PRE>

<P>It computes the inverse of a double precision using the Cholesky factorization
of a <I>N<TT>x</TT>N</I> double precision symmetric positive definite matrix
<I>A</I> stored in the global array represented by <I>g_a</I>. On successful
exit, <I>A</I> will contain the inverse. </P>

<P>It returns </P>

<PRE>            = 0 : successful exit
            &gt; 0 : the leading minor of this order is not positive
                  definite and the factorization could not be completed
            &lt; 0 : it returns the index i of the (i,i)
                  element of the factor L/U that is zero and
                  the inverse could not be computed</PRE>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_llt_solve"></A>GA_LLT_SOLVE </H3>

<PRE>      integer function ga_llt_solve(g_a, g_b)
      integer g_a               [input]          ! coefficient matrix
      integer g_b               [output/output]  ! rhs/solution matrix


</PRE>

<P>Solves a system of linear equations </P>

<PRE>               <I>A</I> * <I>X</I> = <I>B</I>
</PRE>

<P>using the Cholesky factorization of an <I>N</I>x<I>N</I> double precision
symmetric positive definite matrix <I>A</I> (epresented by handle <I>g_a</I>).
On successful exit <I>B </I>will contain the solution <I>X</I>. </P>

<P>It returns: </P>

<PRE>            = 0 : successful exit
            &gt; 0 : the leading minor of this order is not positive
                  definite and the factorization could
                  not be completed</PRE>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_solve"></A>GA_SOLVE </H3>

<PRE>      integer function ga_solve(g_a, g_b)
      integer g_a               [input]          ! coefficient matrix
      integer g_b               [output/output]  ! rhs/solution matrix


</PRE>

<P>Solves a system of linear equations </P>

<PRE>               <I>A</I> * <I>X</I> = <I>B</I>

</PRE>

<P>It first will call the Cholesky factorization routine and, if sucessfully,
will solve the system with the Cholesky solver. If Cholesky will be not
be able to factorize <I>A</I>, then it will call the LU factorization routine
and will solve the system with forward/backward substitution. On exit <I>B</I>
will contain the solution <I>X</I>. </P>

<P>It returns </P>

<PRE>            = 0 : Cholesky factoriztion was succesful
            &gt; 0 : the leading minor of this order
                  is not positive definite, Cholesky factorization
                  could not be completed and LU factoriztion was used</PRE>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_dgemm"></A>GA_DGEMM </H3>

<PRE>      subroutine ga_dgemm(transa, transb, m, n, k, alpha, g_a, g_b, beta, g_c )
      Character*1        transa, transb        [input]
      Integer            m, n, k               [input]
      Double Precision   alpha, beta           [input]
      Integer            g_a, g_b,             [input]
      Integer            g_c                   [output]
 

</PRE>

<P>Performs one of the matrix-matrix operations: </P>

<PRE>         <I>C</I> := <I>alpha*op</I>( <I>A</I> )*<I>op</I>( <I>B</I> ) + <I>beta*C</I>,

</PRE>

<P>where <I>op</I>( X ) is one of </P>

<PRE>         <I>op</I>( <I>X</I> ) = <I>X</I>   or   <I>op</I>( <I>X</I> ) = <I>X</I>',

</PRE>

<P>alpha and beta are scalars, and A, B and C are matrices, with <I>op</I>(
<I>A</I> ) an <I>m</I> by <I>k</I> matrix, <I>op</I>( <I>B</I> ) a <I>k</I>
by <I>n</I> matrix and <I>C</I> an <I>m</I> by <I>n </I>matrix. </P>

<P>On entry, transa specifies the form of <I>op</I>( <I>A</I> ) to be used
in the matrix multiplication as follows: </P>

<PRE>               transa = 'N' or 'n',  op( A ) = A.
               transa = 'T' or 't',  op( A ) = A'.
 
      m      - On entry,  m  specifies  the number  of rows  of the  matrix
               op( A )  and of the  matrix  C.  m  must  be at least  zero.
      n      - On entry,  n  specifies the number  of columns of the matrix
               op( B ) and the number of columns of the matrix C. n must be
               at least zero.
      k      - On entry,  k  specifies  the number of columns of the matrix
               op( A ) and the number of rows of the matrix op( B ). K must
               be at least  zero.
</PRE>

<P>This is a collective operation.</P>

<PRE>
<HR></PRE>

<H3><A NAME="ga_copy"></A>GA_COPY </H3>

<PRE>      subroutine ga_copy(g_a, g_b)
 
      integer g_a, g_b                    [input]

</PRE>

<P>Copies elements in array represented by <I>g_a</I> into the array represented
by <I>g_b</I>. The arrays must be the same type, shape, and identically
aligned. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_copy_patch"></A>GA_COPY_PATCH </H3>

<PRE>      subroutine ga_copy_patch(trans, g_a, ailo, aihi, ajlo, ajhi,
                                  g_b, bilo, bihi, bjlo, bjhi)
 
      character trans                     [input] transpose operator
      integer g_a, g_b                    [input]
      integer ailo, aihi, ajlo, ajhi      [input] g_a patch coordinates
      integer bilo, bihi, bjlo, bjhi      [input] g_b patch coordinates


</PRE>

<P>Copies elements in a patch of one array into another one. The patches
of arrays must have the same number of elements. </P>

<DD><I>trans</I> = 'N' or 'n' means that the transpose operator should
<B>not</B> be applied.</DD>

<DD><I>trans </I>= 'T' or 't' means that transpose operator should be applied.</DD>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_get"></A>GA_GET </H3>

<PRE>      subroutine ga_get(g_a, ilo, ihi, jlo, jhi, buf, ld)

      integer g_a                          [input]
      integer ilo, ihi, jlo, jhi           [input]
      double precision/complex/integer buf [output]
      integer ld                           [input]


</PRE>

<P>Performs the equivalent of the following Fortran-90.</P>

<PRE>      dimension A(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      buf(1:ihi-ilo+1, 1:jhi-jlo+1) = A(ilo:ihi, jlo:jhi)</PRE>

<PRE>where <I>g_a</I> represents a handle to the array <I>A</I>.</PRE>

<PRE>Array bounds are always checked.


<HR></PRE>

<H3><A NAME="ga_put"></A>GA_PUT </H3>

<PRE>      subroutine ga_put(g_a, ilo, ihi, jlo, jhi, buf, ld)

      integer g_a                          [input]
      integer ilo, ihi, jlo, jhi           [input]
      double precision/complex/integer buf [output]
      integer ld                           [input]


</PRE>

<P>Performs the equivalent of the following Fortran-90:</P>

<PRE>      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      g_a(ilo:ihi, jlo:jhi) = buf(1:ihi-ilo+1, 1:jhi-jlo+1)
</PRE>

<PRE>where g_a represents a handle to the array A.</PRE>

<PRE>Array bounds are always checked.


<HR></PRE>

<H3><A NAME="ga_acc"></A>GA_ACC </H3>

<PRE>      subroutine ga_acc(g_a, ilo, ihi, jlo, jhi, buf, ld, alpha)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      double precision/complex buf        [input]
      integer ld                          [input]
      double precision/complex alpha      [input]


</PRE>

<P>Performs the equivalent of the following Fortran-90. Array bounds are
always checked. Double precision/complex types are supported. The operation
is atomic. </P>

<PRE>      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      A(ilo:ihi, jlo:jhi) = A(ilo:ihi, jlo:jhi) + 
                              alpha*buf(1:ihi-ilo+1, 1:jhi-jlo+1)

where g_a represents a handle to the array A.



<HR>
</PRE>

<H3><A NAME="ga_distribution"></A>GA_DISTRIBUTION </H3>

<PRE>      subroutine ga_distribution(g_a, iproc, ilo, ihi, jlo, jhi)

      integer g_a, iproc                  [input]
      integer ilo, ihi, jlo, jhi          [output]
 
       g_a             - array handle [input]
       iproc           - process number [input]
       ilo/ihi/jlo/jhi - range held by process iproc [output]


</PRE>

<P>If no array elements are owned by process <I>iproc</I>, the range is
returned as [0, -1] for the <I>i</I> and [0,-1] for the <I>j</I> dimensions.
</P>

<P>
<HR></P>

<H3><A NAME="ga_compare_distr"></A>GA_COMPARE_DISTR </H3>

<PRE>      logical function ga_compare_distr(g_a, g_b)

      integer g_a, g_b                   [input]


</PRE>

<P>Compares distributions of two global arrays. Returns <I>.TRUE.</I> if
distributions are identical. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_access"></A>GA_ACCESS </H3>

<PRE>      subroutine ga_access(g_a, ilo, ihi, jlo, jhi, index, ld)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      integer index                       [output]
      integer ld                          [output]


</PRE>

<P>Provides access to the specified patch of array. Returns leading dimension
ld and and MA-like index for the data. This routine is intended for writing
new GA operations. Call to <I>ga_access </I>should normally follow a call
to <A HREF="#ga_distribution">ga_distribution</A> that returns coordinates
of the patch associated with a processor. You need to make sure that the
coordinates of the patch are valid (test values returned from <I>ga_distribution</I>).
</P>

<P>Your code should include a MA include file, mafdecls.h. The addressing
convention: </P>

<PRE>       
          dbl_mb(index)  - for double precision data
          int_mb(index)  - for integer data  </PRE>

<PRE>          dcpl_mb(index) - for double complex data
      
</PRE>

<P>provides access to the first element (<I>ilo</I>,<I>jlo</I>) of the
patch. </P>

<P>For a given subroutine: </P>

<PRE>          subroutine foo(A,  nrows, ncols lda)
          double precision A(lda,*)
          integer nrows, ncols
             ....
          end
</PRE>

<P>you can reference <I>A</I>(<I>ilo</I>:<I>ihi</I>,<I>jlo</I>:<I>jhi</I>)
in the following way: </P>

<PRE>          call foo(dbl_mb(index), ihi-ilo+1, jhi-jlo+1, lda)

</PRE>

<P>NOTE: You have to worry about mutual exclusion in simultaneous overlapping
access to the data by multiple processors (critical sections are not protected).
</P>

<P>Each call to <I>ga_access</I> has to be followed by a call to either
<A HREF="#ga_release_update">ga_release</A> or <A HREF="#ga_release_update">ga_release_update</A>.
You can access only <I>local</I> data. </P>

<P>
<HR></P>

<H3><A NAME="ga_release"></A>GA_RELEASE </H3>

<PRE>      subroutine ga_release(g_a, ilo, ihi, jlo, jhi)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]

</PRE>

<P>Releases access to a global array when the data was read only. </P>

<P>Your code should look like: </P>

<PRE>           call ga_distribution(g_a, myproc, ilo,ihi,jlo,jhi)
           call ga_access(g_a, ilo, ihi, jlo, jhi, index, ld)
               
                &lt; operate on the data &gt;

           call ga_release(g_a, ilo, ihi, jlo, jhi) 


</PRE>

<P>NOTE: see restrictions specified for <A HREF="#ga_access">ga_access</A>
</P>

<P>
<HR></P>

<H3><A NAME="ga_release_update"></A>GA_RELEASE_UPDATE </H3>

<PRE>      subroutine ga_release_update(g_a, ilo, ihi, jlo, jhi)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]

</PRE>

<P>Releases access to the data. It must be used if the data was accessed
for writing. NOTE: see restrictions specified for <A HREF="#ga_access">ga_access</A>.
</P>

<P>
<HR></P>

<H3><A NAME="ga_read_inc"></A>GA_READ_INC </H3>

<PRE> integer function ga_read_inc(g_a, i, j, inc)

      integer g_a                         [input]
      integer i, j, inc                   [input]

</PRE>

<P>Atomically read and increment an element in an integer array. </P>

<PRE>      *BEGIN CRITICAL SECTION*
      return value = a(i,j)
      a(i,j) += inc
      *END CRITICAL SECTION*





<HR>

</PRE>

<H3><A NAME="ga_scatter"></A>GA_SCATTER </H3>

<PRE>      subroutine ga_scatter(g_a, v, i, j, n)

      integer g_a                         [input]
      double precision v(n)               [input]
      integer i(n), j(n), n               [input]

</PRE>

<P>Scatters the array elements into the array. The contents of the input
arrays (<I>v</I>, <I>i</I>, <I>j</I>) are preserved, but their contents
might be (consistently) shuffled on return. </P>

<PRE>      do k = 1, nv
             a(i(k),j(k)) = v(k)    
      enddo




<HR>

</PRE>

<H3><A NAME="ga_gather"></A>GA_GATHER </H3>

<PRE>      subroutine ga_gather(g_a, v, i, j, n)

      integer g_a                         [input]
      double precision v(n)               [output]
      integer i(n), j(n), n               [input]

</PRE>

<P>Gathers specified elements (<I>i,j</I>) from the global array into a
local single-dimesional array. The contents of the arrays (<I>v, i, j</I>)
might be (consistently) shuffled on return. </P>

<PRE>      do k = 1, nv
           v(k) =  a(i(k),j(k))
      enddo




<HR>

</PRE>

<H3><A NAME="ga_error"></A>GA_ERROR </H3>

<PRE>      subroutine ga_error(message, code)
      character*1 message(*)              [input]
      integer     code                    [input]

</PRE>

<P>To be called in case of an error. Print an error message and an integer
value that is intended to be the error code. Releases some system resources.
This is the recomended way of aborting the program execution. </P>

<P>
<HR></P>

<H3><A NAME="ga_locate"></A>GA_LOCATE </H3>

<PRE>      logical function ga_locate(g_a, i, j, owner)

      integer g_a, i, j                   [input]
      integer owner                       [output]


</PRE>

<P>Return in owner the GA compute process id that 'owns' the data. If <I>i/j
</I>are out of bounds <I>.FALSE.</I> is returned, otherwise .<I>TRUE.</I>.
</P>

<P>
<HR></P>

<H3><A NAME="ga_locate_region"></A>GA_LOCATE_REGION </H3>

<PRE>      logical function ga_locate_region(g_a, ilo, ihi, jlo, jhi, map, np )

      integer g_a, ilo, ihi, jlo, jhi              [input]
      integer map(5,*), np                         [output]


</PRE>

<P>Parts of the specified patch might be actually 'owned' by several (precisely
np) processes. Return the list of the GA processes id that 'own' the data.
If <I>i/j</I> are out of bounds <I>.FALSE.</I> is returned, otherwise <I>.TRUE.</I>.
</P>

<PRE>        map(1,*)    -  ilo
        map(2,*)    -  ihi
        map(3,*)    -  jlo
        map(4,*)    -  jhi
</PRE>

<P>specify coordinates of a subpatch 'held' by the process which number
is stored in <I>map</I>(5,*) 
<HR></P>

<H3><A NAME="ga_inquire"></A>GA_INQUIRE </H3>

<PRE>      subroutine ga_inquire(g_a, type, dim1, dim2)

      integer g_a                        [input]
      integer type                       [output]
      integer dim1                       [output]
      integer dim2                       [output]


</PRE>

<P>Returns type and dimensions of array. </P>

<P>
<HR></P>

<H3><A NAME="ga_inquire_memory"></A>GA_INQUIRE_MEMORY </H3>

<PRE>    integer function ga_inquire_memory()

</PRE>

<P>Returns amount of memory (in bytes) used in the allocated global arrays
on the calling processor. </P>

<P>
<HR></P>

<H3><A NAME="ga_inquire_name"></A>GA_INQUIRE_NAME </H3>

<PRE>      subroutine ga_inquire_name(g_a, array_name)

      integer g_a                        [input]
      character*(*) array_name           [output]


</PRE>

<P>Returns the name of an array represented by the handle <I>g_a.</I> </P>

<P>
<HR></P>

<H3><A NAME="ga_memory_avail"></A>GA_MEMORY_AVAIL </H3>

<PRE>   integer function ga_memory_avail()

</PRE>

<P>Returns amount of memory (in bytes) left for allocation of new global
arrays on the calling processor. </P>

<P>Note: If <A HREF="#ga_uses_ma">ga_uses_ma</A> returns true, then <I>ga_memory_avail</I>
returns the lesser of the amount available under the GA limit and the amount
available from MA (according to <I>ma_inquire_avail </I>operation). If
no GA limit has been set, it returns what MA says is available. </P>

<P>If ( ! <A HREF="#ga_uses_ma">ga_uses_ma</A>() &amp;&amp; ! <A HREF="#ga_memory_limited">ga_memory_limited</A>()
) returns &lt; 0, indicating that the bound on currently available memory
cannot be determined. </P>

<P>
<HR></P>

<H3><A NAME="ga_uses_ma"></A>GA_USES_MA </H3>

<PRE>      logical function ga_uses_ma()

</PRE>

<P>Returns .<I>true</I>. if memory in global arrays comes from the Memory
Allocator (MA). .<I>false.</I> means that memory comes from another source,
for example System V shared memory is used. </P>

<P>
<HR></P>

<H3><A NAME="ga_memory_limited"></A>GA_MEMORY_LIMITED </H3>

<PRE>      logical function ga_memory_limited()

</PRE>

<P>Indicates if limit is set on memory usage in Global Arrays on the calling
processor. </P>

<P>
<HR></P>

<H3><A NAME="ga_proc_topology"></A>GA_PROC_TOPOLOGY </H3>

<PRE>      subroutine ga_proc_topology(g_a, proc, prow, pcol)

      integer g_a                         [input]
      integer proc                        [input] 
      integer prow, pcol                  [output]


</PRE>

<P>Based on the distribution of the array associated with handle <I>g_a,</I>
determines block row and column coordinates for the array section 'owned'
by specified processor. The numbering starts from 0. The value of -1 means
that the processor doesn't 'own' any section of array represented by <I>g_a</I>.
</P>

<P>
<HR></P>

<H3><A NAME="ga_print_patch"></A>GA_PRINT_PATCH </H3>

<PRE>      subroutine ga_print_patch(g_a,ilo,ihi,jlo,jhi,pretty)
      
      integer g_a                         [input]
      integer ilo,ihi,jlo,jhi             [input] coordinates of the patch
      integer pretty                      [input]

</PRE>

<P>Prints a patch of g_a array to the standard output. If pretty has the
value 0 then output is printed in a dense fashion. If pretty has the value
1 then output is formatted and rows/columns labeled. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_print"></A>GA_PRINT </H3>

<PRE>      subroutine ga_print(g_a)
      
      integer g_a                         [input]

</PRE>

<P>Prints an entire array to the standard output. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_print_stats"></A>GA_PRINT_STATS </H3>

<PRE>      subroutine ga_print_stats()

</PRE>

<P>This non-collective (MIMD) operation prints information about: </P>

<UL>
<LI>number of calls to the GA create/duplicate, destroy, get, put, scatter,
gather, and read_and_inc operations </LI>

<LI>total amount of data moved in the GA primitive operations </LI>

<LI>amount of data moved in GA primitive operations to logicaly remote
locations </LI>

<LI>maximum memory consumption in global arrays, and </LI>

<LI>number of requests serviced in the interrupt-driven implementations
by the calling process. </LI>
</UL>

<P>
<HR></P>

<H3><A NAME="ga_check_handle"></A>GA_CHECK_HANDLE </H3>

<PRE>      subroutine ga_check_handle(g_a, string)
      integer g_a                         [input]
      character *(*) string               [input]
 

</PRE>

<P>Check that the global array handle g_a is valid ... if not call <A HREF="#ga_error">ga_error</A>
with the string provided and some more info. </P>

<P>
<HR></P>

<H3><A NAME="ga_init_fence"></A>GA_INIT_FENCE </H3>

<PRE>      subroutine ga_init_fence()


</PRE>

<P>Initializes tracing of completion status of data movement operations.
</P>

<P>
<HR></P>

<H3><A NAME="ga_fence"></A>GA_FENCE </H3>

<PRE>      subroutine ga_fence()


</PRE>

<P>Blocks the calling process until all the data transfers corresponding
to GA operations called after <A HREF="#ga_init_fence">ga_init_fence</A>
complete. For example, since <A HREF="#ga_put">ga_put</A> might return
before the data reaches the final destination ga_init_fence and ga_fence
allow process to wait until the data is actually moved: </P>

<PRE>           call ga_init_fence()
           call ga_put(g_a, ...)
           call ga_fence()


</PRE>

<P><I>ga_fence</I> must be called after <I>ga_init_fence</I>. A barrier,
<A HREF="#ga_sync">ga_sync</A>, assures completion of all data transfers
and implicitly cancels outstanding <I>ga_init_fence</I>. <I>ga_init_fence</I>
and <I>ga_fence</I> must be used in pairs, multiple calls to <I>ga_fence</I>
require the same number of corresponding <I>ga_init_fence</I> calls. <I>ga_init_fence/ga_fence
</I>pairs can be nested. </P>

<P>ga_fence works for multiple GA operations. For example: </P>

<PRE>           call ga_init_fence()
           call ga_put(g_a, ...)
           call ga_scatter(g_a, ...)
           call ga_put(g_b, ...)
           call ga_fence()


</PRE>

<P>The calling process will be blocked until data movements initiated by
two calls to <A HREF="#ga_put">ga_put</A> and one <A HREF="#ga_scatter">ga_scatter</A>
complete. </P>

<P>
<HR WIDTH="100%"></P>

<H3><A NAME="ga_create_mutexes"></A>GA_CREATE_MUTEXES</H3>

<PRE>      logical function ga_create_mutexes(number)</PRE>

<PRE>      integer number             [input] </PRE>

<P>Creates a set containing the <I>number</I> of mutexes. Returns <I>.true.
</I>if the opereation succeeded or <I>.false. </I>when failed. Mutex is
simple synchronization object used to protect Critical Section. Only one
set of mutexes can exist at a time. Mutexes can be created and destroyed
as many times as needed. </P>

<P>Mutexes are numbered: 0, ..., <I>number</I> -1.</P>

<P>This is a collective operation.</P>

<P>
<HR WIDTH="100%"></P>

<H3><A NAME="ga_destroy_mutexes"></A>GA_DESTROY_MUTEXES</H3>

<PRE>       logical function ga_destroy_mutexes()</PRE>

<P>Destroys the set of mutexes created with <A HREF="#ga_create_mutexes">ga_create_mutexes</A>.
Returns .<I>true</I>. if the operation succeeded or .<I>false</I>. when
failed. </P>

<P>This is a collective operation.</P>

<P>
<HR WIDTH="100%"></P>

<H3><A NAME="ga_lock"></A>GA_LOCK</H3>

<UL>
<PRE>   subroutine ga_lock(mutex)</PRE>

<PRE>   integer mutex      [input]   ! mutex id</PRE>
</UL>

<P>Locks a mutex object identified by the <I>mutex </I>number. It is a
fatal error for a process to attempt to lock a mutex which was already
locked by this process.</P>

<P>
<HR WIDTH="100%"></P>

<H3><A NAME="ga_unlock"></A>GA_UNLOCK</H3>

<PRE>        subroutine ga_unlock(mutex)</PRE>

<PRE>        integer mutex [input] ! mutex id</PRE>

<P>Unlocks a mutex object identified by the <I>mutex</I> number. It is
a fatal error for a process to attempt to unlock a mutex which has not
been locked by this process.</P>

<P>
<HR></P>

<H3><A NAME="ga_nodeid"></A>GA_NODEID </H3>

<PRE>      integer function ga_nodeid()


</PRE>

<P>Returns the GA process <I>id </I>(0, ..., <A HREF="#ga_nnodes">ga_nnodes</A>()-1)
of the requesting compute process. </P>

<P>NOTE: the GA process <I>id</I> might not be the same as message-passing
node <I>id</I>. </P>

<P>
<HR></P>

<H3><A NAME="ga_nnodes"></A>GA_NNODES </H3>

<PRE>   integer function ga_nnodes()

</PRE>

<P>Returns the number of the GA compute (user) processes. </P>

<P>NOTE: the number of the GA processes might not be the same as the number
of the message-passing nodes. </P>

<P>
<HR></P>

<H3><A NAME="ga_brdcst"></A>GA_BRDCST </H3>

<PRE>      subroutine ga_brdcst(type, buf, lenbuf, root)
      integer type       [input]         ! message type for broadcast
      byte buf(lenbuf)   [input/output]
      integer lenbuf     [input]
      integer root       [input]


</PRE>

<P>Broadcast from process root to all other processes a message of length
lenbuf. </P>

<P>This is a convenience operation available regardless of the message-passing
library that GA is running with. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_dgop"></A>GA_DGOP </H3>

<PRE>      subroutine ga_dgop(type, x, n, op)
      integer type             [input]
      double precision x(n)    [input/output]
      character*(*) op         [input]


</PRE>

<P>Double Global OPeration. </P>

<P><I>X</I>(<I>1</I>:<I>N</I>) is a vector present on each process. DGOP
'sums' elements of <I>X</I> accross all nodes using the commutative operator
OP. The result is broadcast to all nodes. Supported operations include
'+', '*', 'max', 'min', 'absmax', 'absmin'. The use of lowerecase for operators
is necessary. </P>

<P>This is a convenience operation, available regardless of the message-passing
library that GA is running with. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_igop"></A>GA_IGOP </H3>

<PRE>      subroutine ga_igop(type, x, n, op)
      integer type              [input]
      integer x(n)              [input/output]
      character*(*) OP          [input]


</PRE>

<P>Integer Global OPeration. The integer version of <A HREF="#ga_dgop">ga_dgop</A>
described above, also include the bitwise OR operation. </P>

<P>This is a convenience operation available regardless of the message-passing
library that GA is running with. </P>

<P>This is a collective operation.</P>

<P>
<HR></P>

<H3><A NAME="ga_list_nodeid"></A>GA_LIST_NODEID </H3>

<PRE>      subroutine ga_list_nodeid(list, n)
      integer n                 [input]
      integer list(n)           [output]

</PRE>

<P>Returns message-passing process ID (rank in MPI) for the GA processes
in the range 0 .. <I>n</I>-1. For MPI, the ranks are in <I>MPI_COMM_WORLD</I>.
</P>

<P>
<HR></P>

<H3><A NAME="ga_mpi_communicator"></A>GA_MPI_COMMUNICATOR </H3>

<PRE>      void ga_mpi_communicator(GA_COMM)
      MPI_Comm *GA_COMM;       [output]


</PRE>

<P>Available in C only if MPI is used. Returns communicator handle for
GA processes (group). </P>

<P>
<HR></P>

</BODY>
</HTML>
