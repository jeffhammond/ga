		      Global Array Documentation
                      --------------------------

		 Robert J. Harrison and Jarek Nieplocha  
   




DISCLAIMER

This material was prepared as an account of work sponsored by an
agency of the United States Government.  Neither the United States
Government nor the United States Department of Energy, nor Battelle,
nor any of their employees, MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR
ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY,
COMPLETENESS, OR USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT,
SOFTWARE, OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT
INFRINGE PRIVATELY OWNED RIGHTS.



ACKNOWLEDGMENT

This software and its documentation were produced with United States
Government support under Contract Number DE-AC06-76RLO-1830 awarded by
the United States Department of Energy.  The United States Government
retains a paid-up non-exclusive, irrevocable worldwide license to
reproduce, prepare derivative works, perform publicly and display
publicly by or for the US Government, including the right to
distribute to other US Government contractors.




   Globally addressable arrays have been developed to simplify writing
   portable scientific software for both shared and distributed memory
   computers.  Programming convenience, code extensibility and 
   maintainability are gained by adopting the shared memory programming 
   model.

   From the user perspective, a global array can be used as it was stored 
   in the shared memory. Details of the data distribution, addressing and
   communication are encapsulated in the global array objects. However, 
   the information on the actual data distribution can be obtained and 
   taken advantage of whenever data locality is important.

   Currently support is limited to 2-D double precision or integer arrays
   with block distribution, at most one block per array per processor.


   Basic operations
   ----------------

   a) Operations that are globally synchronous ... i.e. must
      be simultaneously invoked by all processes as if in SIMD mode.

      ga_initialize   ... initialize global array internal structures 
      ga_create       ... create an array (integer or double precision)
      ga_create_irreg ... create an array with irregular distribution
                          (integer or double precision)
      ga_destroy      ... destroy an array
      ga_terminate    ... destroy all existing arrays and delete internal
                          data structures  
      ga_sync         ... synchronize processes (a barrier)
      ga_zero         ... zero an array
      ga_ddot         ... dot product of two arrays (doubles only)
      ga_dscal        ... scale the elements in an array by a constant
                          (doubles only)
      ga_dadd         ... scale and add two arrays to put result in a third
                          (may overwrite one of the other two, doubles only)
      ga_copy         ... copy one array into another
      ga_dgemm        ... BLAS-like matrix multiply 
      ga_ddot_patch   ... dot product of two arrays (doubles only)
                          (patch version)
      ga_dscal_patch  ... scale the elements in an array by a constant
                          (patch version)
      ga_dadd_patch   ... scale and add two arrays to put result in a third
                          (patch version)
      ga_copy_patch   ... copy one array into another (patch version)
      ga_ifill_patch  ... fill a patch of array with value (integer version)
      ga_dfill_patch  ... fill a patch of array with value (DP version)
      ga_mulmat_patch ... matrix multiply (patch version)
      ga_diag         ... real symmetric generalized eigensolver 
      ga_diag_reuse   ... a version of ga_diag for repeated use    
      ga_diag_std     ... standard real symmetric eigensolver 
      ga_symmetrize   ... symmetrize a matrix
      ga_transpose    ... transpose a matrix
      ga_lu_solve     ... solve system of linear equations based on LU 
                          factorization 
      ga_print_patch  ... print a patch of an array to the screen 
      ga_print        ... print an entire array to the screen
      ga_copy_patch   ... copy data from a patch of one global array

   b) Operations that may be invoked by any process in true MIMD style

      ga_get           ... read from a patch of an array
      ga_put           ... write to a patch of an array
      ga_acc           ... accumulate into a patch of an array (double
                           precision only)
      ga_dscatter      ... scatter elements into an array (double 
                           precision only)
      ga_dgather       ... gather elements from an array (double precision only)
      ga_read_inc      ... atomically read and increment the value of
                           a single array element (integers only)
      ga_locate        ... determine which process 'holds' an array element
      ga_locate_region ... determine which process 'holds' an array patch 
      ga_error         ... print error message and terminate the program 

   c) Operations that may be invoked by any process in true MIMD style
      and are intended to support writing of new (data parallel?) functions

      ga_inquire       ... find the name, type and dimensions of the array
      ga_distribution  ... find coordinates of the array patch that is 
                          'held' by a processor 
      ga_access        ... access internal data
      ga_release       ... relinquish access to internal data
      ga_release_update... relinquish access after data were updated 
      ga_mask          ... protect critical sections
      ga_check_handle  ... verify that a GA handle is valid

   d) Operations to support portability between implementations

      ga_nodeid       ... find requesting compute process id
      ga_nnodes       ... find number of compute processes
      ga_dgop         ... equivalent to TCGMSG dgop for compute processes
      ga_brdcst       ... equivalent to TCGMSG brdcst for compute processes


      Note that consistency is only guaranteed for

          i)   Multiple read operations (as the data does not change)
          ii)  Multiple accumulate operations (as addition is commutative) 
          iii) Multiple disjoint put operations (as there is only one writer 
               for each element)

      The application has to worry about everything else (usually
      by appropriate insertion of ga_sync calls)


  Status of current implementation
  --------------------------------
  
  There are three platforms that GA work on: 

  1) Network of workstations, using the data-server/compute_node model
     where each user's process (compute-node) is coupled with additional
     process (data-server) that services requests for the data.
     It is recommended that each pair of data-server and compute_node
     is executing on the same workstation (2 processes on a workstation).
     Lower half of processes specified in the TCGMSG *.p file are considered
     to be compute nodes, and the upper half the data servers. Therefore,
     the number of processes has to be even. Any i-th compute process
     is associated with the i+P/2 data server process. 

  2) True message passing MPP architectures with interrupt communication
     available: the Intel IPSC, Delta, Paragon with the NX, and the IBM SP-1
     with the EUIH message passing library. 

  3) Shared memory machines like: the KSR-2, SGI, SUN, and the IBM RS/6000 
     workstations.

  The shared memory implementation uses TCGMSG to fork all the processes
  and implement ga_brdcst and ga_dgop (might change someday). There are
  no data server processes; therefore, all the processes specified in *.p 
  file are used for computations. 


  Your program should look like
  -----------------------------

  call pbeginf()                  ! start TCGMSG
  status = ma_init(..)            ! start memory allocate if required
  call ga_initialize()            ! start global arrays

  .... do work

  call ga_terminate               ! tidy up global arrays
  call pend                       ! tidy up tcgmsg
  stop                            ! exit program

  The ma_init call looks like

    status = ma_init(type, stack_size, heap_size)

  and it basically just goes to the OS and gets stack_size+heap_size
  elements of size type.  On distributed memory platforms, if you
  allocate a global array of size N elements, you need to ensure that
  the call to ma_initialize gets at least N/(no. of data server
  processes) elements per process (in the data server model only the
  highest numbered half of the processes need do this).


  Prototypes of GA Subroutines and Functions
  ------------------------------------------



      subroutine ga_initialize()

      allocate and initialize internal data structures for global arrays

      -------------------------------------------------------------------
      logical function ga_create(type, dim1, dim2, array_name,
     $     chunk1, chunk2, g_a)

      integer type, dim1, dim2, chunk1, chunk2, g_a
      character*(*) array_name

       array_name    - a unique character string [input]
 
       type          - MA type [input]
 
       dim1/2        - array(dim1,dim2) as in FORTRAN [input]
 
       chunk1/2      - minimum size that dimensions should
                       be chunked up into [input]
                       setting chunk1=dim1 gives distribution by 
                               vertical strips (chunk2 columns)
                       setting chunk2=dim2 gives distribution by
                               horizontal strips (chunk1 rows)
                       Actual chunks will be modified so that
                       they are at least the size of the minimum and
                       each process has either zero or one chunk.
 
                       Specifying chunk1/2 as <= 1 will cause that
                       dimension to be distributed evenly.
                       [Current distribution algorithm is primitive !]
 
       g_a           - integer handle for future references [output]

      -------------------------------------------------------------------
      logical function ga_create_irreg(type, dim1, dim2, array_name,
     $     map1, nblock1, map2, nblock2,  g_a)

      integer type, map1(*), map2(*), nblock1, nblock2, g_a
      character*(*) array_name

       array_name    - a unique character string [input]
 
       type          - MA type [input]
 
       dim1/2        - array(dim1,dim2) as in FORTRAN [input]
 
       nblock1       - no. of blocks first dimension is divided into [input]
 
       nblock2       - no. of blocks second dimension is divided into [input]
 
       map1          - ilo for each block [input]
 
       map2          - jlo for each block [input]
 
       g_a           - integer handle for future references [output]

      -------------------------------------------------------------------
      logical function ga_destroy(g_a)
  
      integer g_a     [input]

      Deallocates the array and frees any associated resources

      -------------------------------------------------------------------
      subroutine ga_terminate()

      Delete all active arrays and destroy internal data structures

      -------------------------------------------------------------------
      subroutine ga_sync()

      Synchronize processes (a barrier) and ensure that all global
      array operations are complete (or at least appear complete).
      
      -------------------------------------------------------------------
      subroutine ga_zero(g_a)

      integer g_a                         [input]

      Zeroes the contents of the array and behaves like

      ga_zero()
         ga_sync()        ! Barrier to ensure all processes in ga_zero
         zero the array   
         ga_sync()        ! Barrier to ensure no reads before zero complete

      -------------------------------------------------------------------
      double precision function ga_ddot(g_a, g_b)

      integer g_a, g_b                    [input]

      Computes the element-wise dot product of the two arrays which
      must be double precision, the same shape and identically aligned.
  
         ga_ddot = sum(i,j) a(i,j)*b(i,j)

      -------------------------------------------------------------------
      double precision function ga_ddot_patch(g_a, ailo, aihi, ajlo, ajhi,
                                              g_b, bilo, bihi, bjlo, bjhi) 

      integer g_a, g_b                    [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates
      integer  bilo, bihi, bjlo, bjhi     [input] g_b patch coordinates

      Computes the element-wise dot product of the two patches which
      must be double precision and have the same number of elements. 

      -------------------------------------------------------------------
      subroutine ga_dscal(g_a, s)
 
      integer g_a                         [input]
      double precision s                  [input]

      Scales the double precision array by the constant s.

      -------------------------------------------------------------------
      subroutine ga_dscal_patch(g_a, ailo, aihi, ajlo, ajhi, s)

      integer g_a                         [input]
      double precision s                  [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates

      Scales the patch of double precision array by the constant s.

      -------------------------------------------------------------------
      subroutine ga_dadd(alpha, g_a, beta, g_b, g_c)

      integer g_a, g_b, g_c               [input]
      double precision alpha, beta        [input]

      The double precision arrays (which must be the same shape and
      identically aligned) are added together element-wise

           c = alpha * a  +  beta * b

      The result (c) may replace one of the input arrays (a/b).

      -------------------------------------------------------------------
      subroutine ga_dadd_patch (alpha, g_a, ailo, aihi, ajlo, ajhi,
                                beta,  g_b, bilo, bihi, bjlo, bjhi,
                                       g_c, cilo, cihi, cjlo, cjhi)

      integer g_a, g_b, g_c               [input]
      double precision alpha, beta        [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates
      integer  bilo, bihi, bjlo, bjhi     [input] g_b patch coordinates
      integer  cilo, cihi, cjlo, cjhi     [input] g_c patch coordinates

      Patches of double precision arrays (which must have the same number 
      of elements) are added together element-wise.

      -------------------------------------------------------------------
      subroutine ga_dfill_patch(g_a, ailo, aihi, ajlo, ajhi, s)

      integer g_a                         [input]
      double precision s                  [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates

      Fills the patch of double precision array with value s.

      -------------------------------------------------------------------
      subroutine ga_ifill_patch(g_a, ailo, aihi, ajlo, ajhi, s)

      integer g_a                         [input]
      integer s                           [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates

      Fills the patch of integer array with value s.

      -------------------------------------------------------------------
      subroutine ga_symmetrize(g_a)

      integer g_a                         [input/output]

      Symmetrizes matrix g_a:  g_a := .5 * (g_a+g_a')

      -------------------------------------------------------------------
      subroutine ga_diag(g_a, g_s, g_v, eval)

      integer g_a               [input]   ! Matrix to diagonalize
      integer g_s               [input]   ! Metric
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals

      Solve the generalized eigen-value problem returning
      all eigen-vectors and values in ascending order.
 
      The input matrices are not destroyed.

      -------------------------------------------------------------------
      subroutine ga_diag_reuse(control, g_a, g_s, g_v, eval)

      integer control           [input]   ! control flag 
      integer g_a               [input]   ! Matrix to diagonalize
      integer g_s               [input]   ! Metric
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals

      Solve the generalized eigen-value problem returning
      all eigen-vectors and values in ascending order. 
      Recommended for REPEATED calls if g_s is unchanged.

      Values of the control flag:
             value       action/purpose
   
              0          first call to the eigensolver
             >0          consecutive calls (reuses factored g_s)
             <0          only erases factorized g_s; g_v and eval unchanged
                         (should be called after previous use if another 
                         eigenproblem, i.e., different g_a and g_s, is to 
                         be solved)

      The input matrices are not destroyed.

      -------------------------------------------------------------------
      subroutine ga_diag_std(g_a, g_s, g_v, eval)

      integer g_a               [input]   ! Matrix to diagonalize
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals

      Solve the standard (non-generalized) eigenvalue problem returning
      all eigenvectors and values in ascending order.

      The input matrix is not destroyed.

      -------------------------------------------------------------------
      subroutine ga_lu_solve(trans, g_a, g_b)

      character trans           [input]          ! transpose or not transpose 
      integer g_a               [input]          ! coefficient matrix
      integer g_b               [output/output]  ! rhs matrix

      Solve the system of linear equations op(A)X = B based on the LU
      factorization. op(A) = A or A' depending on the parameter trans.
    
      Matrix A is a general real matrix. Matrix B contains possibly
      multiple rhs vectors.  

      Array g_b is overwritten by the solution matrix X.

      -------------------------------------------------------------------
      subroutine ga_dgemm(transa, transb, m, n, k, alpha, g_a, g_b,
     $                   beta, g_c )
      Character*1        transa, transb        [input]
      Integer            m, n, k               [input]
      Double Precision   alpha, beta           [input]
      Integer            g_a, g_b,             [input]
      Integer            g_c                   [output]
 
      ga_dgemm  performs one of the matrix-matrix operations:
         C := alpha*op( A )*op( B ) + beta*C,
      where  op( X ) is one of
         op( X ) = X   or   op( X ) = X',
 
      alpha and beta are scalars, and A, B and C are matrices, with op( A )
      an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
 
      On entry, transa specifies the form of op( A ) to be used in
      the matrix multiplication as follows:
               transa = 'N' or 'n',  op( A ) = A.
               transa = 'T' or 't',  op( A ) = A'.
 
      m      - On entry,  m  specifies  the number  of rows  of the  matrix
               op( A )  and of the  matrix  C.  m  must  be at least  zero.
      n      - On entry,  n  specifies the number  of columns of the matrix
               op( B ) and the number of columns of the matrix C. n must be
               at least zero.
      k      - On entry,  k  specifies  the number of columns of the matrix
               op( A ) and the number of rows of the matrix op( B ). K must
               be at least  zero.

      -------------------------------------------------------------------
      subroutine ga_copy(g_a, g_b)
 
      integer g_a, g_b                    [input]

      Copies a element-wise into b.  The arrays (integer or double) must
      be the same shape and identically aligned.

      -------------------------------------------------------------------
      subroutine ga_copy_patch(trans, g_a, t_a, ailo, aihi, ajlo, ajhi,
                                      g_b, bilo, bihi, bjlo, bjhi)
 
      character t_a                       [input] transpose operator
      integer g_a, g_b                    [input]
      integer ailo, aihi, ajlo, ajhi      [input] g_a patch coordinates
      integer bilo, bihi, bjlo, bjhi      [input] g_b patch coordinates

      Copies a element-wise into b.  The patches of arrays (double) must
      have the same number of elements. 

      -------------------------------------------------------------------
      subroutine ga_get(g_a, ilo, ihi, jlo, jhi, buf, ld)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      integer/double precision buf        [output]
      integer ld                          [input]

      Performs the equivalent of the following Fortran-90.  Array
      bounds are always checked and both integer and doubles are supported.

      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      buf(1:ihi-ilo+1, 1:jhi-jlo+1) = g_a(ilo:ihi, jlo:jhi)

      -------------------------------------------------------------------
      subroutine ga_put(g_a, ilo, ihi, jlo, jhi, buf, ld)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      integer/double precision buf        [input]
      integer ld                          [input]

      Performs the equivalent of the following Fortran-90.  Array
      bounds are always checked and both integer and doubles are supported.

      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      g_a(ilo:ihi, jlo:jhi) = buf(1:ihi-ilo+1, 1:jhi-jlo+1)

      -------------------------------------------------------------------
      subroutine ga_acc(g_a, ilo, ihi, jlo, jhi, buf, ld, alpha)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      double precision buf                [input]
      integer ld                          [input]
      double precision alpha              [input]

      Performs the equivalent of the following Fortran-90.  Array
      bounds are always checked and only double precision is supported.

      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      g_a(ilo:ihi, jlo:jhi) = g_a(ilo:ihi, jlo:jhi) + 
     $                        alpha*buf(1:ihi-ilo+1, 1:jhi-jlo+1)

      -------------------------------------------------------------------
      subroutine ga_distribution(g_a, iproc, ilo, ihi, jlo, jhi)

      integer g_a, iproc                  [input]
      integer ilo, ihi, jlo, jhi          [output]
 
       g_a             - array handle [input]
       iproc           - process number [input]
       ilo/ihi/jlo/jhi - range held by process iproc [output]
       If proc doesn't 'have' any data the range is returned as
       [0, -1] for the i and [0,-1] for the j dimensions.

       Note for the data server implementation: the data is actually
       local to the data server process and not the compute processes.
       Thus, you probably do not want to use this routine unless U
       understand what is going on in some detail.

      -------------------------------------------------------------------
      subroutine ga_access(g_a, ilo, ihi, jlo, jhi, index, ld)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      integer index                       [output]
      integer ld                          [output]

      Provides access to the specified patch of array. Returns leading
      dimension ld and and MA-like index for the data. This routine is
      intended for writing new GA operations. Call to ga_access should
      normally follow call to ga_distribution that returns coordinates
      of the patch associated with a processor. You need to make sure
      that coordinates of the patch are valid (test values returned
      from ga_distribution).

      Your code should include a MA include file,  mafdecls.h. 
      The addressing convention:
       
          dbl_mb(index)  - for double precision data 
          int_mb(index)  - for integer data
      
      provides access to the first element (ilo,jlo) of the patch.

      If you have a subroutine:
          
          subroutine foo(A,  nrows, ncols lda)
          double precision A(lda,*)
          integer nrows, ncols
             ....
          end

      you can can call it for g_a(ilo:ihi,jlo:jhi) in the following way:

          call foo(dbl_mb(index), ihi-ilo+1, jhi-jlo+1, lda)

      NOTE:

      You have to worry about mutal exclusion in simultaneous overlapping
      access to the data by multiple processors (critical sections are not 
      protected). 

      Each call to ga_access has to be followed by a call to either
      ga_release or ga_release_update. 
   
      Only one access to an array per processor is allowed at a time.

      You can access only local data. 

      -------------------------------------------------------------------
      subroutine ga_release(g_a, ilo, ihi, jlo, jhi)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]

      Releases access to a global array when the data was read only. 

      Your code should look like:

           call ga_distribution(g_a, myproc, ilo,ihi,jlo,jhi)
           call ga_access(g_a, ilo, ihi, jlo, jhi, index, ld)
               
                < operate on the data >

           call ga_release(g_a, ilo, ihi, jlo, jhi) 

      NOTE: see restrictions specified for ga_access

      -------------------------------------------------------------------
      subroutine ga_release_update(g_a, ilo, ihi, jlo, jhi)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]

      Releases access to the data. It must be used if the data was 
      accessed for writing.

      NOTE: see restrictions specified for ga_access

      -------------------------------------------------------------------
      integer function ga_read_inc(g_a, i, j, inc)

      integer g_a                         [input]
      integer i, j, inc                   [input]

      Atomically read and increment an element in an integer array.

      *BEGIN CRITICAL SECTION*
      return value = a(i,j)
      a(i,j) += inc
      *END CRITICAL SECTION*
	
      -------------------------------------------------------------------
      subroutine ga_dscatter(g_a, v, i, j, n)

      integer g_a                         [input]
      double precision v(n)               [input]
      integer i(n), j(n), n               [input]

      Scatters the array elements into the array, only double
      precision being supported.  The contents of the input arrays (v,
      i, j) are preserved, but their contents might be (consistently)
      shuffled on returned.

              do k = 1, nv
                 a(i(k),j(k)) = v(k)
              enddo
    
      -------------------------------------------------------------------
      subroutine ga_dgather(g_a, v, i, j, n)

      integer g_a                         [input]
      double precision v(n)               [output]
      integer i(n), j(n), n               [input]

      Gathers the array elements from the array, only double
      precision being supported.  The contents of the input arrays 
      (v, i, j) are preserved.

              do k = 1, nv
                 v(k) = a(i(k),j(k))
              enddo

      -------------------------------------------------------------------
      subroutine ga_error(message, code)
      character*1 message(*)              [input]
      integer     code                    [input]

      Called in case of an error. Print an error message + an integer
      value that is itended to be the error code. Releases some system
      resources.

      -------------------------------------------------------------------
      logical function ga_locate(g_a, i, j, owner)

      integer g_a, i, j                   [input]
      integer owner                       [output]

      Return in owner the GA compute process id that 'owns' the data.
      If i/j are out of bounds .FALSE. is returned, otherwise .TRUE..

      -------------------------------------------------------------------
      logical function ga_locate_region(g_a, ilo, ihi, jlo, jhi, map, np )

      integer g_a, ilo, ihi, jlo, jhi              [input]
      integer map(5,*), np                         [output]

      Parts of the specified patch might be actually 'owned' by several
      (precisely np) processes.

      Return the list of the GA processes id that 'own' the data.
      If i/j are out of bounds .FALSE. is returned, otherwise .TRUE..
        
        map(2,*)    -  ilo'
        map(3,*)    -  ihi'
        map(4,*)    -  jlo'
        map(5,*)    -  jhi'

      specify coordinates of a subpatch 'held' by the process map(1,*)

      -------------------------------------------------------------------
      subroutine ga_inquire(g_a, type, dim1, dim2)

      integer g_a                         [input]
      integer type                       [output]
      integer dim1                       [output]
      integer dim2                       [output]

      Returns type, and dimensions of array

      -------------------------------------------------------------------
      subroutine ga_inquire_name(g_a, array_name)

      integer g_a                         [input]
      character*(*) array_name           [output]

      Returns name of array

      -------------------------------------------------------------------
      subroutine ga_copy_from_patch(trans, g_a, ilo,ihi,jlo,jhi, g_b)

      character trans                     [input] transpose flag
      integer g_a                         [input] handle to src array
      integer g_b                         [input] handle to dst array
      integer ilo,ihi,jlo,jhi             [input] coordinates of the patch

      copies a patch of g_a to g_b
               g_b = op(g_a[ilo:ihi, jlo:jhi])
      where op(g_a) means
               g_a  if trans is 'n' or 'N'   
               g_a' otherwise

      g_b has to have dimensions conforming to the size of the patch

      NOTE: available only on the shared memory platforms and might disappear

      -------------------------------------------------------------------
      subroutine ga_copy_to_patch(trans, g_a, ilo,ihi,jlo,jhi, g_b)

      character trans                     [input] transpose flag
      integer g_a                         [input] handle to dst array
      integer g_b                         [input] handle to src array
      integer ilo,ihi,jlo,jhi             [input] coordinates of the patch

      copies  g_b to a patch of g_a 
               g_a[ilo:ihi, jlo:jhi] = op(g_b)
      where op(g_b) means
               g_b  if trans is 'n' or 'N'   
               g_b' otherwise

      g_b has to have dimensions conforming to the size of the patch

      NOTE: available only on the shared memory platforms and might disappear
            
      -------------------------------------------------------------------
      subroutine ga_print_patch(g_a,ilo,ihi,jlo,jhi,pretty)
      
      integer g_a                         [input]
      integer ilo,ihi,jlo,jhi             [input] coordinates of the patch
      integer pretty                      [input] 

      Prints a patch of g_a array to the standard output.  If pretty has
      the value 0 then output is printed in a dense fashion.  If pretty
      has the value 1 then output is formatted and rows/columns labelled.

      -------------------------------------------------------------------
      subroutine ga_print(g_a)
      
      integer g_a                         [input]

      Prints an entire g_a array to the standard output.

      -------------------------------------------------------------------
      integer function ga_mask(newmask)
      integer newmask                     [input]
 
      Set the mask for the receipt of remote accesses to local data
      returning the old value of the mask
 
      newmask = 1 (disabled ... use to enter critical section)
      newmask = 0 (enabled  ... use to exit  critical section)
 

      This is intended for mostly internal use, e.g. when updating
      data when it is possible that interrupts may arrive.

      e.g.,

           oldmask = ga_mask(1)
           <critical section>
           oldmask = ga_mask(oldmask)

      -------------------------------------------------------------------
      subroutine ga_check_handle(g_a, string)
      integer g_a                         [input]
      character *(*) string               [input]
 
      Check that the global array handle g_a is valid ... if not
      call ga_error with the string provided and some more info
 
      -------------------------------------------------------------------
      integer function ga_nodeid()

      Returns the GA process id (0, ..., ga_nnodes()-1) of the
      requesting compute process.

      -------------------------------------------------------------------
      integer function ga_nnodes()

      Returns the number of GA compute processes.



   C language interface 
   --------------------

   Subroutines and functions listed above can be called from C
   programs.  It is required to add an underscore at the end of the
   routine names.  There are also some GA routines that have both C and
   Fortran versions, for example, ga_error, ga_check_handle or
   ga_inquire_name. The reason for having two separate versions was to
   avoid Fortran to C character string conversion, at least in the
   routines that are supposed to be called quite frequently.

   In case of Fortran routines that require a character string
   (ga_create_, for example), one extra argument has to be added at the
   end of the argument list. It is a length of the string (as returned
   by strlen()) and it must be a value not a pointer. All the other
   Fortran arguments are passed by pointers. For an example on how to
   use GAs in C programs, see implementation of GA operations in
   global.alg.c file, where some other GA routines are called.

   To use ga_access, two external symbols (base arrays) have to be
   declared:

   extern DoublePrecision *DBL_MB; 
   extern Integer         *INT_MB;

   and types.f2c.h header file has to be included.  For portability
   purposes, it is recommended to use in your C program DoublePrecision
   and Integer data types defined in types.f2c.h.

   ga_access returns an index that is used to reference the data with
   respect to the data base arrays. This index corresponds to the
   Fortran addressing convention so to use it in C, you need to
   decrement it by one.

   Some GA routines that operate on  DoublePrecision and Integer data 
   objects. Identifiers for these data types (MT_F_DBL and MT_F_INT)
   are defined in macommon.h that is located in the MA directory.
