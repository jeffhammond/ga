		      Global Array Documentation
                      --------------------------




DISCLAIMER

This material was prepared as an account of work sponsored by an
agency of the United States Government.  Neither the United States
Government nor the United States Department of Energy, nor Battelle,
nor any of their employees, MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR
ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY,
COMPLETENESS, OR USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT,
SOFTWARE, OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT
INFRINGE PRIVATELY OWNED RIGHTS.



ACKNOWLEDGMENT

This software and its documentation were produced with United States
Government support under Contract Number DE-AC06-76RLO-1830 awarded by
the United States Department of Energy.  The United States Government
retains a paid-up non-exclusive, irrevocable worldwide license to
reproduce, prepare derivative works, perform publicly and display
publicly by or for the US Government, including the right to
distribute to other US Government contractors.




   Globally addressable arrays have been developed to simplify writing
   portable scientific software for both shared and distributed memory
   computers.  Programming convenience, code extensibility and 
   maintainability are gained by adopting the shared memory programming 
   model.

   From the user perspective, a global array can be used as it was stored 
   in the shared memory. Details of the data distribution, addressing and
   communication are encapsulated in the global array objects. However, 
   the information on the actual data distribution can be obtained and 
   taken advantage of whenever data locality is important.

   Currently support is limited to 2-D double precision, double complex
   or integer arrays with block distribution, at most one block per
   array per processor.


   Basic operations
   ----------------

   a) Operations that are globally collective ... i.e. must
      be simultaneously invoked by all processes as if in SIMD mode.

      ga_initialize     ... initialize global array internal structures 
      ga_initialize_ltd ... initialize global arrays and set memory usage limits
      ga_create         ... create an array
      ga_create_irreg   ... create an array with irregular distribution
      ga_duplicate      ... create an array following a reference array 
      ga_destroy        ... destroy an array
      ga_terminate      ... destroy all existing arrays and delete internal
                            data structures  
      ga_sync           ... synchronize processes (a barrier)
      ga_zero           ... zero an array
      ga_ddot           ... dot product of two arrays (doubles only)
      ga_zdot           ... dot product of two arrays (double complex only)
      ga_scale          ... scale the elements in an array by a constant
      ga_add            ... scale and add two arrays to put result in a third
                            (may overwrite one of the other two)
      ga_copy           ... copy one array into another
      ga_dgemm          ... BLAS-like matrix multiply 
      ga_ddot_patch     ... dot product of two patches (doubles only)
      ga_zdot_patch     ... dot product of two patches (double complex only)
      ga_scale_patch    ... scale the elements in an array by a constant
                            (patch version)
      ga_add_patch      ... scale and add two arrays to put result in a third
                            (patch version)
      ga_fill_patch     ... fill a patch of array with value
      ga_matmul_patch   ... matrix multiply (patch version)
      ga_diag           ... real symmetric generalized eigensolver 
                            (sequential version also exists)
      ga_diag_reuse     ... a version of ga_diag for repeated use    
      ga_diag_std       ... standard real symmetric eigensolver 
                            (sequential version also exists)
      ga_symmetrize     ... symmetrize a matrix
      ga_transpose      ... transpose a matrix
      ga_lu_solve       ... solve system of linear equations based on LU 
                            factorization (sequential version also exists) 
      ga_print_patch    ... print a patch of an array to the screen 
      ga_print          ... print an entire array to the screen
      ga_copy_patch     ... copy data from a patch of one global array
                            into another array
      ga_compare_distr  ... compare distributions of two global arrays

   b) Operations that may be invoked by any process in true MIMD style

      ga_get            ... read from a patch of an array
      ga_put            ... write to a patch of an array
      ga_acc            ... accumulate into a patch of an array (double
                            precision only)
      ga_scatter        ... scatter elements into an array
      ga_gather         ... gather elements from an array
      ga_read_inc       ... atomically read and increment the value of
                            a single array element (integers only)
      ga_locate         ... determine which process 'holds' an array element
      ga_locate_region  ... determine which process 'holds' an array section
      ga_error          ... print error message and terminate the program 
      ga_summarize      ... print information about already allocated arrays
      ga_init_fence     ... traces completion of data movement operations 
      ga_fence          ... blocks until the initiated communication completes 

   c) Operations that may be invoked by any process in true MIMD style
      and are intended to support writing of new functions

      ga_distribution   ... find coordinates of the array patch that is 
                            'held' by a processor 
      ga_access         ... access internal data
      ga_release        ... relinquish access to internal data
      ga_release_update ... relinquish access after data were updated 
      ga_check_handle   ... verify that a GA handle is valid

   d) Operations to support portability between implementations

      ga_nodeid         ... find requesting compute process message id
      ga_nnodes         ... find number of compute processes
      ga_dgop           ... reduce operation (double) equivalent to TCGMSG dgop 
      ga_igop           ... reduce operation (integer) equivalent to TCGMSG igop
      ga_brdcst         ... broadcast operation equivalent to TCGMSG brdcst

   e) Other utility operations

      ga_inquire        ... find the type and dimensions of the array
      ga_inquire_name   ... find the name of the array
      ga_inquire_memory ... find the amount of memory in active arrays 
      ga_memory_avail   ... find the amount of memory left for GA 
      ga_summarize      ... prints summary info about allocated arrays
      ga_uses_ma        ... finds if memory in arrays comes from MA 
                            (memory allocator)
      ga_memory_limited ... finds if limits were set for memory usage in arrays
      ga_proc_topology  ... finds block coordinates for the array section
                            held by a processor
      ga_list_nodeid    ... returns message-passing process id for GA processes


      Note that consistency is only guaranteed for

          i)   Multiple read operations (as the data does not change)
          ii)  Multiple accumulate operations (as addition is commutative) 
          iii) Multiple disjoint put operations (as there is only one writer 
               for each element)

      The application has to worry about everything else (usually by
      appropriate insertion of ga_sync calls)


  Status of current implementation (version 2.2)
  --------------------------------

  There are two classes of platforms that GA work on: 

  1) Network of (possibly multiprocessor) machines, using the
     data-server/compute-nodes model where each machine needs an
     additional process (data-server) that services requests for the
     data. Therefore, number of processes specified in the TCGMSG *.p
     file minus one are considered to be compute nodes, and remaining
     ones are the data servers. Data servers use shared memory to
     access the data on local machine.

     Example .p file for one 4-processor and one 8-processor workstations:

         d3h325 coho 4 /usr/people/d3h325/g/global/testing/test.x /tmp
         d3h325 bohr 8 /usr/people/d3h325/g/global/testing/test.x /tmp

     defines 10 compute processes and 2 data-servers (one on coho and 
     one on bohr).

     Single (possibly multiprocessor) machines with shared memory
     like:  the KSR-2, workstations, and even Cray T3D are in fact a
     special case of 1).  The shared memory implementation uses TCGMSG
     (in the future MPI) to fork all the processes (except for the 
     Cray T3D) and implement ga_brdcst and ga_dgop. There are no data server
     processes; therefore, all the specified processes/processors are
     used for computations.


  2) True message passing MPP architectures with interrupt communication
     available: the Intel IPSC, Delta, Paragon with the NX, and the IBM SP-1/2
     with the EUIH or MPL message passing library. 


  Starting with version 2.1, Global Arrays works with either TCGMSG or
  MPI message-passing librarries.  TCGMSG still is and going to be the
  default library for a while until MPI implementations mature. There are 
  two possible interfaces between GA and MPI:

     1. TCGMSG emulation library, TCGMSG-MPI, that implements functionality
        of TCGMSG using MPI and other techniques. In this mode, message-
        passing library is initialized using TCGMSG PBEGIN(F) which
        internally calls MPI_Initialize. In this mode, TCGMSG-MPI might
        'steal' one process from the application to implement NXTVAL
        operation. To enable this mode, define environmental variable
        USE_MPI and MPI_LIB and MPI_INCLUDE which should point to the 
        location of the MPI library and include directories. 

     2. Direct MPI-GA interface. In this mode, GA program should contain 
        MPI initialization calls instead PBEGIN(F).

  In both the cases, GA programs are started with the mechanism that
  any other MPI programs use on the given platform. In particular,
  neither the TCGMSG parallel command nor .p file is used.

  Your program should look like
  -----------------------------

  1. with TCGMSG or TCGMSG-MPI (GA-MPI interface 1) library:

  call pbeginf()                  ! start TCGMSG
  status = ma_init(..)            ! start memory allocator if required
  call ga_initialize()            ! start global arrays

  .... do work

  call ga_terminate()             ! tidy up global arrays
  call pend()                     ! tidy up tcgmsg
  stop                            ! exit program

  2. with MPI  (GA-MPI interface 2) library:

  call MPI_Initialize()           ! start MPI
  status = ma_init(..)            ! start memory allocator if required
  call ga_initialize()            ! start global arrays

  .... do work

  call ga_terminate()             ! tidy up global arrays
  call MPI_Finalize()             ! tidy up MPI
  stop                            ! exit program
  call MPI_Initialize()           ! start MPI
  status = ma_init(..)            ! start memory allocator if required
  call ga_initialize()            ! start global arrays

  .... do work

  call ga_terminate()             ! tidy up global arrays
  call MPI_Finalize()             ! tidy up MPI
  stop                            ! exit program


  The ma_init call looks like

    status = ma_init(type, stack_size, heap_size)

  and it basically just goes to the OS and gets stack_size+heap_size
  elements of size type.  On distributed memory platforms, if you
  allocate a global array of size N elements, you need to ensure that
  the call to ma_init gets at least N/(no. of GA processes) elements
  per process. 

  Message-Passing in GA Programs
  ------------------------------

  There are two issues to be aware of when using message-passing in GA
  programs:

    1. Process count and numbering. In the network environment,
       some message-passing processes are hiden from the application
       when GA is initialized. This will cause that ga_nodeid() and
       ga_nnodes() return values inconsistent with the process
       rank/count values obtained from the message-passing library. The
       GA routine ga_list_nodeid() could be used to transform GA
       process ID/rank into the message-passing process ID/rank. In
       addition, with MPI library, C-language routine
       ga_mpi_communicator provides communicator for the GA processes.
       This operation is unavailable if the original TCGMSG library is
       used. ga_mpi_communicator cannot be called from Fortran since
       there is no mechanism in MPI for passing handles between C and
       Fortran. Contact MPI Forum for fixing this problem !

    2. Synchronization. The current implementation of interrupt-receive
       on the IBM SP requires that in order to avoid deadlock, GA application
       must synchronize (ga_sync()) before and after message-passing 
       communication calls. This means that GA and message-passing 
       communication must be separated into different phases. 

               ...
           <GA communication phase>
           ga_sync()
           <message-passing phase>
           ga_sync()
           <GA communication phase>
               ...
        

  Prototypes of GA Subroutines and Functions
  ------------------------------------------


      subroutine ga_initialize()

      Allocate and initialize internal data structures for global arrays.

      -------------------------------------------------------------------
      subroutine ga_initialize_ltd(limit)
      integer limit  - amount of memory in bytes per process [input]

      Allocate and initialize internal data structures for global arrays
      and set limit for memory used in global arrays.

      limit < 0 means "unlimited memory usage" 

      -------------------------------------------------------------------
      logical function ga_create(type, dim1, dim2, array_name,
     $                                    chunk1, chunk2, g_a)

      integer type, dim1, dim2, chunk1, chunk2, g_a
      character*(*) array_name

       array_name    - a unique character string [input]
 
       type          - MA type [input]
 
       dim1/2        - array(dim1,dim2) as in FORTRAN [input]
 
       chunk1/2      - minimum size that dimensions should
                       be chunked up into [input]
                       setting chunk1=dim1 gives distribution by 
                               vertical strips (chunk2 columns)
                       setting chunk2=dim2 gives distribution by
                               horizontal strips (chunk1 rows)
                       Actual chunks will be modified so that
                       they are at least the size of the minimum and
                       each process has either zero or one chunk.
 
                       Specifying chunk1/2 as <= 1 will cause that
                       dimension to be distributed evenly.
                       [Current distribution algorithm is primitive !]
 
       g_a           - integer handle for future references [output]


      Creates an array.

      -------------------------------------------------------------------
      logical function ga_create_irreg(type, dim1, dim2, array_name,
     $                                 map1, nblock1, map2, nblock2,  g_a)

      integer type, map1(*), map2(*), nblock1, nblock2, g_a
      character*(*) array_name

       array_name    - a unique character string [input]
 
       type          - MA type [input]
 
       dim1/2        - array(dim1,dim2) as in FORTRAN [input]
 
       nblock1       - no. of blocks first dimension is divided into [input]
 
       nblock2       - no. of blocks second dimension is divided into [input]
 
       map1          - ilo for each block [input]
 
       map2          - jlo for each block [input]
 
       g_a           - integer handle for future references [output]

      Creates an array by following the user-specified distribution.

      -------------------------------------------------------------------
      logical function ga_duplicate(g_a, g_b, array_name)
      integer *g_a, *g_b;
      char *array_name;

      array_name    - a character string [input]
      g_a           - Integer handle for reference array [input]
      g_b           - Integer handle for new array [output]

      Creates a new array by applying all the properties of another
      existing array.

      -------------------------------------------------------------------
      logical function ga_destroy(g_a)
  
      integer g_a     [input]

      Deallocates the array and frees any associated resources

      -------------------------------------------------------------------
      subroutine ga_terminate()

      Delete all active arrays and destroy internal data structures

      -------------------------------------------------------------------
      subroutine ga_sync()

      Synchronize processes (a barrier) and ensure that all global
      array operations are complete (or at least appear complete).
      
      -------------------------------------------------------------------
      subroutine ga_zero(g_a)

      integer g_a                         [input]

      Zeroes the contents of the array and behaves like

      ga_zero()
         ga_sync()        ! Barrier to ensure all processes in ga_zero
         zero the array   
         ga_sync()        ! Barrier to ensure no reads before zero complete

      -------------------------------------------------------------------
      double precision function ga_ddot(g_a, g_b)
      double precision function ga_zdot(g_a, g_b)

      integer g_a, g_b                    [input]

      Computes the element-wise dot product of the two arrays which
      must be double precision/complex, the same shape and identically 
      aligned.
  
         ga_*dot = sum(i,j) a(i,j)*b(i,j)

      -------------------------------------------------------------------
      double precision function ga_ddot_patch(g_a, ta, ailo, aihi, ajlo, ajhi,
                                              g_b, tb, bilo, bihi, bjlo, bjhi) 
      double precision function ga_zdot_patch(g_a, ta, ailo, aihi, ajlo, ajhi,
                                              g_b, tb, bilo, bihi, bjlo, bjhi) 

      integer     g_a, g_b                   [input]
      integer     ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates
      integer     bilo, bihi, bjlo, bjhi     [input] g_b patch coordinates
      character*1 ta, tb                     [input] transpose flags

      Computes the element-wise dot product of the two (possibly
      transposed) patches which must be double precision/complex and
      have the same number of elements.

      -------------------------------------------------------------------
      subroutine ga_matmul_patch(transa, transb, alpha, beta,
     $                           g_a, ailo, aihi, ajlo, ajhi,
     $                           g_b, bilo, bihi, bjlo, bjhi,
     $                           g_c, cilo, cihi, cjlo, cjhi)

     integer g_a, ailo, aihi, ajlo, ajhi;    [input]  patch of g_a
     integer g_b, bilo, bihi, bjlo, bjhi;    [input]  patch of g_b
     integer g_c, cilo, cihi, cjlo, cjhi;    [input]  patch of g_c 
     double precision/complex alpha, beta;   [input]
     character*1    transa, transb;          [input]

      ga_matmul_patch is a patch version of ga_dgemm: 
         C[cilo:cihi,cjlo:cjhi] := alpha* AA[ailo:aihi,ajlo:ajhi] *
                                   BB[bilo:bihi,bjlo:bjhi] ) +
                                   beta*C[cilo:cihi,cjlo:cjhi],
      where  AA = op(A), BB = op(B), and op( X ) is one of
         op( X ) = X   or   op( X ) = X',

      Valid values for transpose arguments:  'n', 'N', 't', 'T'.

      It works for both double precision and double complex data type.

      -------------------------------------------------------------------
      subroutine ga_scale(g_a, s)
 
      integer g_a                         [input]
      double precision/complex/integer s  [input]

      Scales an array  by the constant s.

      -------------------------------------------------------------------
      subroutine ga_scale_patch(g_a, ailo, aihi, ajlo, ajhi, s)

      integer g_a                         [input]
      double precision/complex/integer s  [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates

      Scales a patch of an array by the constant s.

      -------------------------------------------------------------------
      subroutine ga_add(alpha, g_a, beta, g_b, g_c)

      integer g_a, g_b, g_c                          [input]
      double precision/complex/integer alpha, beta   [input]

      The  arrays (which must be the same shape and
      identically aligned) are added together element-wise

           c = alpha * a  +  beta * b

      The result (c) may replace one of the input arrays (a/b).

      -------------------------------------------------------------------
      subroutine ga_add_patch (alpha, g_a, ailo, aihi, ajlo, ajhi,
                               beta,  g_b, bilo, bihi, bjlo, bjhi,
                                      g_c, cilo, cihi, cjlo, cjhi)

      integer g_a, g_b, g_c               [input]
      double precision/complex/integer alpha, beta   [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates
      integer  bilo, bihi, bjlo, bjhi     [input] g_b patch coordinates
      integer  cilo, cihi, cjlo, cjhi     [input] g_c patch coordinates

      Patches of arrays (which must have the same number of elements)
      are added together element-wise.

      -------------------------------------------------------------------
      subroutine ga_fill_patch(g_a, ailo, aihi, ajlo, ajhi, s)

      integer g_a                         [input]
      double precision/complex/integer s  [input]
      integer  ailo, aihi, ajlo, ajhi     [input] g_a patch coordinates

      Fills the patch of array with value s.

      -------------------------------------------------------------------
      subroutine ga_summarize(verbose)
      logical verbose                     [input]! If true print 
                                                   distribution info

      Prints info about allocated arrays.

      -------------------------------------------------------------------
      subroutine ga_symmetrize(g_a)

      integer g_a                         [input/output]

      Symmetrizes matrix g_a:  g_a := .5 * (g_a+g_a')

      -------------------------------------------------------------------
      subroutine ga_transpose(g_a, g_b)

      integer g_a                         [input]  ! remains unchanged
      integer g_b                         [output]

      Transposes a matrix: g_b = g_a'

      -------------------------------------------------------------------
      subroutine ga_diag(g_a, g_s, g_v, eval)

      integer g_a               [input]   ! Matrix to diagonalize
      integer g_s               [input]   ! Metric
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals

      Solve the generalized eigen-value problem returning
      all eigen-vectors and values in ascending order.
 
      The input matrices are not overwritten or destroyed.

      -------------------------------------------------------------------
      subroutine ga_diag_reuse(control, g_a, g_s, g_v, eval)

      integer control           [input]   ! control flag 
      integer g_a               [input]   ! Matrix to diagonalize
      integer g_s               [input]   ! Metric
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals

      Solve the generalized eigen-value problem returning
      all eigen-vectors and values in ascending order. 
      Recommended for REPEATED calls if g_s is unchanged.

      Values of the control flag:
             value       action/purpose
   
              0          indicates first call to the eigensolver
             >0          consecutive calls (reuses factored g_s)
             <0          only erases factorized g_s; g_v and eval unchanged
                         (should be called after previous use if another 
                         eigenproblem, i.e., different g_a and g_s, is to 
                         be solved)

      The input matrices are not destroyed.

      -------------------------------------------------------------------
      subroutine ga_diag_std(g_a, g_v, eval)

      integer g_a               [input]   ! Matrix to diagonalize
      integer g_v               [output]  ! Global matrix to return evecs
      double precision eval(*)  [output]  ! Local array to return evals

      Solve the standard (non-generalized) eigenvalue problem returning
      all eigenvectors and values in the ascending order.

      The input matrix is neither overwritten nor destroyed.

      -------------------------------------------------------------------
      subroutine ga_lu_solve(trans, g_a, g_b)

      character trans           [input]          ! transpose or not transpose 
      integer g_a               [input]          ! coefficient matrix
      integer g_b               [output/output]  ! rhs matrix

      Solve the system of linear equations op(A)X = B based on the LU
      factorization. op(A) = A or A' depending on the parameter trans.
    
      Matrix A is a general real matrix. Matrix B contains possibly
      multiple rhs vectors.  

      Array g_b is overwritten by the solution matrix X.

      -------------------------------------------------------------------
      subroutine ga_dgemm(transa, transb, m, n, k, alpha, g_a, g_b,
     $                   beta, g_c )
      Character*1        transa, transb        [input]
      Integer            m, n, k               [input]
      Double Precision   alpha, beta           [input]
      Integer            g_a, g_b,             [input]
      Integer            g_c                   [output]
 
      ga_dgemm  performs one of the matrix-matrix operations:
         C := alpha*op( A )*op( B ) + beta*C,
      where  op( X ) is one of
         op( X ) = X   or   op( X ) = X',
 
      alpha and beta are scalars, and A, B and C are matrices, with op( A )
      an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
 
      On entry, transa specifies the form of op( A ) to be used in
      the matrix multiplication as follows:
               transa = 'N' or 'n',  op( A ) = A.
               transa = 'T' or 't',  op( A ) = A'.
 
      m      - On entry,  m  specifies  the number  of rows  of the  matrix
               op( A )  and of the  matrix  C.  m  must  be at least  zero.
      n      - On entry,  n  specifies the number  of columns of the matrix
               op( B ) and the number of columns of the matrix C. n must be
               at least zero.
      k      - On entry,  k  specifies  the number of columns of the matrix
               op( A ) and the number of rows of the matrix op( B ). K must
               be at least  zero.

      -------------------------------------------------------------------
      subroutine ga_copy(g_a, g_b)
 
      integer g_a, g_b                    [input]

      Copies g_a element-wise into g_b.  The arrays (integer or double)
      must be the same shape and identically aligned.

      -------------------------------------------------------------------
      subroutine ga_copy_patch(trans, g_a, ailo, aihi, ajlo, ajhi,
                                      g_b, bilo, bihi, bjlo, bjhi)
 
      character trans                     [input] transpose operator
      integer g_a, g_b                    [input]
      integer ailo, aihi, ajlo, ajhi      [input] g_a patch coordinates
      integer bilo, bihi, bjlo, bjhi      [input] g_b patch coordinates

      Copies elements in a patch of one array into another one. The
      patches of arrays must have the same number of elements.

      -------------------------------------------------------------------
      subroutine ga_init_fence()
     
      Initializes tracing of completion status of data movement operations.
     
      -------------------------------------------------------------------
      subroutine ga_fence()

      Blocks the calling process until all the data transfers corresponding
      to GA operations called after ga_init_fence complete. For example,
      since ga_put might return before the data reaches the final destination 
      ga_init_fence and ga_fence allow to wait until the data is actually
      moved:

           call ga_init_fence()
           call ga_put(g_a, ...)
           call ga_fence()

      ga_fence must be called after ga_fence_init. A barrier, ga_sync,
      assures completion of all data transfers and implicitly cancels 
      outstanding ga_init_fence. ga_init_fence and ga_fence must be used
      in pairs, multiple calls to ga_fence require the same number
      of corresponding ga_init_fence calls. ga_init_fence/ga_fence
      pairs can be nested.

      ga_fence works for multiple GA operations. For example:

           call ga_init_fence()
           call ga_put(g_a, ...)
           call ga_scatter(g_a, ...)
           call ga_put(g_b, ...)
           call ga_fence()

      The calling process will be blocked until data movements initiated
      by two calls to ga_put and one ga_scatter complete.

      This is a non-collective operation.

      -------------------------------------------------------------------
      subroutine ga_get(g_a, ilo, ihi, jlo, jhi, buf, ld)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      integer/double precision buf        [output]
      integer ld                          [input]

      Performs the equivalent of the following Fortran-90.  Array
      bounds are always checked and both integer and doubles are supported.

      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      buf(1:ihi-ilo+1, 1:jhi-jlo+1) = g_a(ilo:ihi, jlo:jhi)

      -------------------------------------------------------------------
      subroutine ga_put(g_a, ilo, ihi, jlo, jhi, buf, ld)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      integer/double precision buf        [input]
      integer ld                          [input]

      Performs the equivalent of the following Fortran-90.  Array
      bounds are always checked and both integer and doubles are supported.

      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      g_a(ilo:ihi, jlo:jhi) = buf(1:ihi-ilo+1, 1:jhi-jlo+1)

      -------------------------------------------------------------------
      subroutine ga_acc(g_a, ilo, ihi, jlo, jhi, buf, ld, alpha)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      double precision buf                [input]
      integer ld                          [input]
      double precision alpha              [input]

      Performs the equivalent of the following Fortran-90.  Array
      bounds are always checked and only double precision is supported.
      The operation is atomic.

      dimension g_a(1:dim1,1:dim2)
      dimension buf(1:ld, 1:*)

      g_a(ilo:ihi, jlo:jhi) = g_a(ilo:ihi, jlo:jhi) + 
     $                        alpha*buf(1:ihi-ilo+1, 1:jhi-jlo+1)

      -------------------------------------------------------------------
      subroutine ga_distribution(g_a, iproc, ilo, ihi, jlo, jhi)

      integer g_a, iproc                  [input]
      integer ilo, ihi, jlo, jhi          [output]
 
       g_a             - array handle [input]
       iproc           - process number [input]
       ilo/ihi/jlo/jhi - range held by process iproc [output]

       If proc doesn't 'have' any data the range is returned as
       [0, -1] for the i and [0,-1] for the j dimensions.

      -------------------------------------------------------------------
      logical function ga_compare_distr(g_a, g_b)

      integer g_a, g_b                   [input]

      Compares distributions of two global arrays. Returns .TRUE. if
      distributions are identical.

      -------------------------------------------------------------------
      subroutine ga_access(g_a, ilo, ihi, jlo, jhi, index, ld)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]
      integer index                       [output]
      integer ld                          [output]

      Provides access to the specified patch of array. Returns leading
      dimension ld and and MA-like index for the data. This routine is
      intended for writing new GA operations. Call to ga_access should
      normally follow a call to ga_distribution that returns coordinates
      of the patch associated with a processor. You need to make sure
      that coordinates of the patch are valid (test values returned
      from ga_distribution).

      Your code should include a MA include file,  mafdecls.h. 
      The addressing convention:
       
          dbl_mb(index)  - for double precision data 
          int_mb(index)  - for integer data
      
      provides access to the first element (ilo,jlo) of the patch.

      If you have a subroutine:
          
          subroutine foo(A,  nrows, ncols lda)
          double precision A(lda,*)
          integer nrows, ncols
             ....
          end

      you can can call it for g_a(ilo:ihi,jlo:jhi) in the following way:

          call foo(dbl_mb(index), ihi-ilo+1, jhi-jlo+1, lda)

      NOTE:

      You have to worry about mutual exclusion in simultaneous overlapping
      access to the data by multiple processors (critical sections are not 
      protected). 

      Each call to ga_access has to be followed by a call to either
      ga_release or ga_release_update. 
   
      You can access only local data. 

      -------------------------------------------------------------------
      subroutine ga_release(g_a, ilo, ihi, jlo, jhi)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]

      Releases access to a global array when the data was read only. 

      Your code should look like:

           call ga_distribution(g_a, myproc, ilo,ihi,jlo,jhi)
           call ga_access(g_a, ilo, ihi, jlo, jhi, index, ld)
               
                < operate on the data >

           call ga_release(g_a, ilo, ihi, jlo, jhi) 

      NOTE: see restrictions specified for ga_access

      -------------------------------------------------------------------
      subroutine ga_release_update(g_a, ilo, ihi, jlo, jhi)

      integer g_a                         [input]
      integer ilo, ihi, jlo, jhi          [input]

      Releases access to the data. It must be used if the data was 
      accessed for writing.

      NOTE: see restrictions specified for ga_access

      -------------------------------------------------------------------
      integer function ga_read_inc(g_a, i, j, inc)

      integer g_a                         [input]
      integer i, j, inc                   [input]

      Atomically read and increment an element in an integer array.

      *BEGIN CRITICAL SECTION*
      return value = a(i,j)
      a(i,j) += inc
      *END CRITICAL SECTION*
	
      -------------------------------------------------------------------
      subroutine ga_scatter(g_a, v, i, j, n)

      integer g_a                         [input]
      double precision v(n)               [input]
      integer i(n), j(n), n               [input]

      Scatters the array (integer or double) elements into the array.
      The contents of the input arrays (v, i, j) are preserved, but
      their contents might be (consistently) shuffled on return.

              do k = 1, nv
                 a(i(k),j(k)) = v(k)
              enddo
    
      -------------------------------------------------------------------
      subroutine ga_gather(g_a, v, i, j, n)

      integer g_a                         [input]
      double precision v(n)               [output]
      integer i(n), j(n), n               [input]

      Gathers the array elements  (integer or double) from the array.
      The contents of the input arrays (v, i, j) are preserved.

              do k = 1, nv
                 v(k) = a(i(k),j(k))
              enddo

      -------------------------------------------------------------------
      subroutine ga_error(message, code)
      character*1 message(*)              [input]
      integer     code                    [input]

      Called in case of an error. Print an error message + an integer
      value that is intended to be the error code. Releases some system
      resources. This is the recomended way of aborting the program
      execution.

      -------------------------------------------------------------------
      logical function ga_locate(g_a, i, j, owner)

      integer g_a, i, j                   [input]
      integer owner                       [output]

      Return in owner the GA compute process id that 'owns' the data.
      If i/j are out of bounds .FALSE. is returned, otherwise .TRUE..

      -------------------------------------------------------------------
      logical function ga_locate_region(g_a, ilo, ihi, jlo, jhi, map, np )

      integer g_a, ilo, ihi, jlo, jhi              [input]
      integer map(5,*), np                         [output]

      Parts of the specified patch might be actually 'owned' by several
      (precisely np) processes.

      Return the list of the GA processes id that 'own' the data.
      If i/j are out of bounds .FALSE. is returned, otherwise .TRUE..
        
        map(1,*)    -  ilo'
        map(2,*)    -  ihi'
        map(3,*)    -  jlo'
        map(4,*)    -  jhi'

      specify coordinates of a subpatch 'held' by the process map(5,*)

      -------------------------------------------------------------------
      subroutine ga_inquire(g_a, type, dim1, dim2)

      integer g_a                         [input]
      integer type                       [output]
      integer dim1                       [output]
      integer dim2                       [output]

      Returns type and dimensions of array.

      -------------------------------------------------------------------
      subroutine ga_inquire_name(g_a, array_name)

      integer g_a                         [input]
      character*(*) array_name           [output]

      Returns name of array.

      -------------------------------------------------------------------
      integer function ga_inquire_memory()

      Returns amount of memory (in bytes) used in allocated global arrays
      on the calling processor.

      -------------------------------------------------------------------
      integer function ga_memory_avail()

      Returns amount of memory left for allocation of new global arrays on
      the calling processor.

      Note: If ga_uses_ma() is true, then ga_memory_avail returns the
      lesser of the amount available under the GA limit and the amount
      available from MA (according to ma_inquire_avail).  If no GA
      limit has been set, it returns what MA says is available.

      If ( ! ga_uses_ma() && ! ga_memory_limited() ) returns < 0, 
      indicating that the bound on currently available memory cannot
      be determined.

      -------------------------------------------------------------------
      logical function ga_uses_ma()

      Returns .true. if memory in global arrays comes from memory allocator
      (MA). .false. means that memory comes from another source, for example
      System V shared memory is used.

      -------------------------------------------------------------------
      logical function ga_memory_limited()

      Indicates if limit is set on memory usage in global arrays on
      the calling processor.

      -------------------------------------------------------------------
      subroutine ga_proc_topology(g_a, proc, prow, pcol)

      integer g_a                         [input]
      integer proc                        [input] 
      integer prow, pcol                  [output]

      Based on the distribution of g_a, determines block row and column
      coordinates for the array section 'owned' by specified processor.
      The numbering starts from 0. The value of -1 means that the processor
      doesn't 'own' any section of g_a.

      -------------------------------------------------------------------
      subroutine ga_print_patch(g_a,ilo,ihi,jlo,jhi,pretty)
      
      integer g_a                         [input]
      integer ilo,ihi,jlo,jhi             [input] coordinates of the patch
      integer pretty                      [input] 

      Prints a patch of g_a array to the standard output.  If pretty has
      the value 0 then output is printed in a dense fashion.  If pretty
      has the value 1 then output is formatted and rows/columns labeled.

      -------------------------------------------------------------------
      subroutine ga_print(g_a)
      
      integer g_a                         [input]

      Prints an entire g_a array to the standard output.

      -------------------------------------------------------------------
      subroutine ga_check_handle(g_a, string)
      integer g_a                         [input]
      character *(*) string               [input]
 
      Check that the global array handle g_a is valid ... if not
      call ga_error with the string provided and some more info.
 
      -------------------------------------------------------------------
      integer function ga_nodeid()

      Returns the GA process id (0, ..., ga_nnodes()-1) of the
      requesting compute process.

      NOTE: the GA process id might not be the same as message-passing 
      node id.

      -------------------------------------------------------------------
      integer function ga_nnodes()

      Returns the number of GA compute (user) processes.

      NOTE: the number GA processes might not be the same as the number
      message-passing nodes.

      -------------------------------------------------------------------
      subroutine ga_brdcst(type, buf, lenbuf, root)
      integer type       [input]         ! message type for broadcast
      byte buf(lenbuf)   [input/output]
      integer lenbuf     [input]
      integer root       [input]

      Broadcast from process root to all other processes a message
      of length lenbuf.

      -------------------------------------------------------------------
      subroutine ga_dgop(type, x, n, op)
      integer type             [input]
      double precision x(n)    [input/output]
      character*(*) op         [input]

      Double Global OPeration.
      X(1:N) is a vector present on each process. DGOP 'sums'
      elements of X accross all nodes using the commutative operator
      OP. The result is broadcast to all nodes. Supported operations
      include '+', '*', 'max', 'min', 'absmax', 'absmin'.
      The use of lowerecase for operators is necessary.

      -------------------------------------------------------------------
      subroutine ga_igop(type, x, n, op)
      integer type             [input]
      integer x(n)             [input/output]
      character*(*) OP         [input]

      Integer Global OPeration.
      The integer version of ga_dgop described above, also include the
      bitwise OR operation.

      -------------------------------------------------------------------
      subroutine ga_list_nodeid(list, n)
      integer n                [input]
      integer list(n)          [output]

      Returns message-passing process ID (rank in MPI) for the GA
      processes in the range 0 .. n. For MPI, the ranks are in
      MPI_COMM_WORLD.

      -------------------------------------------------------------------
      void ga_mpi_communicator(GA_COMM)
      MPI_Comm *GA_COMM;       [output]

      Available in C only if MPI is used. Returns communicator handle
      for GA processes (group).

      -------------------------------------------------------------------

   C language interface 
   --------------------

   Subroutines and functions listed above can be also called from C
   programs.  It is required to add an underscore at the end of the
   routine names and include "global.h" file. The GA routines that
   require a character (string) argument have both C (no underscore
   suffix) and Fortran (NOT TO BE USED BY C PROGRAMS) versions, for
   example, ga_error, ga_check_handle or ga_inquire_name. The reason
   for having two separate versions is to avoid sometimes painful
   Fortran to C character string conversion.

   For convenience purposes, starting with version 2.1, global.h header
   file defines names for C routines as having GA_ prefix and no
   underscore suffix, see testc.c or ga-mpi.c for examples. For the
   debugging purpose, the programmer should be still aware of the
   actual naming convention as described above.

   GA arguments are passed by pointers. For an example on how
   to use GAs in C programs, see implementation of GA operations in
   global.alg.c file, where some other GA routines are called.

   See "global.alg.c" for examples on how to use  ga_access in C.

   For portability purposes, it is recommended to use in your C program 
   DoublePrecision and Integer data types defined in "types.f2c.h" 
   (included in "global.h" file).

   ga_access returns an index that is used to reference the data with
   respect to the data base arrays. This index corresponds to the
   Fortran addressing convention so to use it in C, you need to
   decrement it by one, for example DBL_MB[--index] provides value
   of the first element.

   GA routines operate on DoublePrecision and Integer data. 
   Identifiers for these data types (MT_F_DBL and MT_F_INT)
   are defined in macommon.h that is located in the MA directory.

   Compiler Flags
   --------------

   Look at compiler flags in file Makefile.h to make sure that
   Fortran and C compiler flags are consistent with flags used
   to compile your application.
