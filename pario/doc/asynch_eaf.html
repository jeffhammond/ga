<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE></TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (X11; I; Linux 1.2.13 i586) [Netscape]">
</HEAD>
<BODY>

<P><!-- Changed by: Jace A Mogill,  1-Sep-1996 --></P>

<P><!-- Changed by: Jace A Mogill,  1-Sep-1996 --></P>

<UL>
<UL>
<UL>
<P><FONT SIZE=+4>Example EAF Asynchronous Program</FONT></P>
</UL>
</UL>
</UL>

<P>This is a small example of an EAF program which uses asynchronous I/O
to open, write to, then read back from a file.</P>

<P>
<HR SIZE=5 WIDTH="100%"></P>

<PRE>#include &quot;chemio.h&quot;
#include &quot;eaf.fh&quot;

        integer fh              ! File Handle
        integer id1, id2        ! asynchronous ID handles
        integer stat            ! Return status
        integer pend            ! Pending status
        integer iter            ! Iterations counter
        integer buf(100), x     ! Data

        iter = 0

        fh = EAF_OpenScratch('/piofs/mogill/test.out', CHEMIO_RW)

        stat = EAF_AWrite(fh, 0,  buf, 100*EAF_SZ_INT, id1)
        if(stat .ne. 0) write(0,*) 'Error doing 1st asynch write.  stat=', stat

        stat = EAF_AWrite(fh, 100*EAF_SZ_INT,  x, 1*EAF_SZ_INT, id2)
        if(stat .ne. 0) write(0,*) 'Error doing 2nd asynch write.  stat=', stat

100     stat = EAF_Probe(id1, pend)
        iter = iter + 1
        write(0,*) 'Waiting', iter
        if(iter .lt. 100  .and.  pend .eq. CHEMIO_PENDING) goto 100
        EAF_Wait(id1)

        stat = EAF_ARead(fh, 0, buf, 100*EAF_SZ_INT, id1)
        if(stat .ne. 0) write(0,*) 'Error doing 1st asynch read.  stat=', stat

        EAF_Wait(id2)
        stat = EAF_AWrite(fh, 100*EAF_SZ_INT,  x, 1*EAF_SZ_INT, id2)
        if(stat .ne. 0) write(0,*) 'Error doing 2nd asynch write.  stat=', stat
        EAF_Wait(id2)
        EAF_Wait(id1)

        stat = EAF_Close(fh)
        end
</PRE>

<P>
<HR SIZE=5 WIDTH="100%">This example demonstrates use of asynchronous reading
and writing. The entire buffer 'buf' is written to offset 0, the beginning
of the file. The file is simultaniously written to from the scalar <TT>x
</TT>in the position following the buffer. The positions in the file are
determined by abosulte offset argument as with the synchronous write. </P>

<P>The first write, <TT>id1,</TT> is repeatedly probed for completion for
100 tries or until completion, whichever comes first. The two possible
pending statuses are <TT>CHEMIO_DONE </TT>and <TT>CHEMIO_PENDING. </TT></P>

<P>When a completed asynchronous operation is detected with <TT>EAF_Wait</TT>
or <TT>EAF_Probe</TT>, the id is invalidated with <TT>CHEMIO_DONE</TT>.
The following <TT>EAF_Wait(id1)</TT> blocks until <TT>id1</TT> completes.
Using <TT>EAF_Probe</TT> or <TT>EAF_Wait</TT> with an invalidated ID has
no effect. </P>

<P>Once id1 is freed, it is reused in the first asynchronous read statement.
The following <TT>EAF_Wait</TT> blocks for completion and invalidation
of <TT>id2</TT>, which is then used to asynchronouslyread the scalar X.</P>

<P>The <TT>EAF_Close</TT> deletes the file because it was opened as a scratch
(<TT>EAF_OpenScratch</TT>) file.</P>

</BODY>
</HTML>
